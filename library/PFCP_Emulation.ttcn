/* PFCP Emulation in TTCN-3
 *
 * (C) 2022 sysmocom - s.f.m.c. GmbH <info@sysmocom.de>
 * All rights reserved.
 *
 * Released under the terms of GNU General Public License, Version 2 or
 * (at your option) any later version.
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 */

module PFCP_Emulation {

import from IPL4asp_Types all;
import from General_Types all;
import from Osmocom_Types all;
import from PFCP_Types all;
import from PFCP_Templates all;
import from PFCP_CodecPort all;
import from PFCP_CodecPort_CtrlFunct all;

/***********************************************************************
 * Main Emulation Component
 ***********************************************************************/

const integer PFCP_PORT := 8805;

type enumerated PFCP_Role {
	CPF,
	UPF
};

type record PFCP_Emulation_Cfg {
	HostName pfcp_bind_ip,
	PortNumber pfcp_bind_port,
	HostName pfcp_remote_ip,
	PortNumber pfcp_remote_port,
	PFCP_Role role
};

type component PFCP_Emulation_CT {
	/* Communication with underlying PFCP CodecPort */
	port PFCP_PT PFCP;

	/* Communication with Clients */
	port PFCPEM_PT CLIENT;
	port PFCPEM_PROC_PT CLIENT_PROC;

	/* Configuration by the user */
	var PFCP_Emulation_Cfg g_pfcp_cfg;

	/* State */
	var integer g_pfcp_conn_id;
	var integer g_recovery_timestamp;

	var PFCPEM_conns g_conns;

	var integer g_next_sequence_nr_state;
};

private function f_PFCPEM_next_sequence_nr() runs on PFCP_Emulation_CT return integer {
	g_next_sequence_nr_state := g_next_sequence_nr_state + 1;
	if (g_next_sequence_nr_state > 16777215) {
		g_next_sequence_nr_state := 1;
	}
	return g_next_sequence_nr_state;
}

type record PFCPEM_conn {
	PFCP_ConnHdlr vc_conn,
	OCT8 seid optional,
	LIN3_BO_LAST pfcp_msg_sequence_number optional
};

type record of PFCPEM_conn PFCPEM_conns;

private function f_PFCPEM_conn_by_seqnr(LIN3_BO_LAST seqnr)
runs on PFCP_Emulation_CT return PFCP_ConnHdlr {
	for (var integer i := 0; i < lengthof(g_conns); i := i + 1) {
		if (seqnr == g_conns[i].pfcp_msg_sequence_number) {
			return g_conns[i].vc_conn;
		}
	}
	return null;
};

private function f_PFCPEM_conn_by_seid(OCT8 seid)
runs on PFCP_Emulation_CT return PFCP_ConnHdlr {
	for (var integer i := 0; i < lengthof(g_conns); i := i + 1) {
		if (seid == g_conns[i].seid) {
			return g_conns[i].vc_conn;
		}
	}
	return null;
};

private function f_PFCPEM_conn_for_pdu(in PDU_PFCP pdu)
runs on PFCP_Emulation_CT return PFCP_ConnHdlr {
	var PFCP_ConnHdlr vc_conn := null;

	vc_conn := f_PFCPEM_conn_by_seqnr(pdu.sequence_number);
	if (vc_conn != null) {
		return vc_conn;
	}

	/* If there is a SEID, we can look it up */
	if (pdu.s_flag == '1'B) {
		vc_conn := f_PFCPEM_conn_by_seid(pdu.seid);
	}

	return vc_conn;
};

private function f_PFCPEM_conn_add_or_update(in PFCPEM_conn conn)
runs on PFCP_Emulation_CT {
	for (var integer i := 0; i < lengthof(g_conns); i := i + 1) {
		if (g_conns[i].vc_conn == conn.vc_conn) {
			g_conns[i] := conn; /* update */
			return;
		}
	}
	/* Not in the list yet, add. */
	g_conns := g_conns & { conn };
}

private function f_init(PFCP_Emulation_Cfg cfg) runs on PFCP_Emulation_CT {
	var Result res;

	map(self:PFCP, system:PFCP);
	res := PFCP_CodecPort_CtrlFunct.f_IPL4_listen(PFCP, cfg.pfcp_bind_ip, cfg.pfcp_bind_port, {udp:={}});
	g_pfcp_conn_id := res.connId;

	g_recovery_timestamp := f_rnd_int(4294967296);
	g_pfcp_cfg := cfg;

	g_conns := {};

	g_next_sequence_nr_state := (1 + f_rnd_int(1000)) * 10000;
}

function main(PFCP_Emulation_Cfg cfg) runs on PFCP_Emulation_CT {
	var PFCP_ConnHdlr vc_conn;
	var PFCP_Unitdata ud;
	var PDU_PFCP pdu;

	f_init(cfg);

	while (true) {
		alt {
		[] PFCP.receive(tr_PFCP_UD(tr_PFCP_Heartbeat_Req)) -> value ud {
				log("Rx Heartbeat Req: ", ud.pdu);
				pdu := valueof(ts_PFCP_Heartbeat_Resp(g_recovery_timestamp));
				pdu.sequence_number := ud.pdu.sequence_number;
				ud.pdu := pdu;
				PFCP.send(ud);
			}

		[] PFCP.receive(tr_PFCP_UD(?)) -> value ud {
				log("PFCP_Emulation main() PFCP.receive: ", ud);
				vc_conn := f_PFCPEM_conn_for_pdu(ud.pdu);
				if (vc_conn != null) {
					log("found destination ", vc_conn);
					CLIENT.send(ud.pdu) to vc_conn;
				} else {
					log("sending to all conns: ", g_conns);
					for (var integer i := 0; i < lengthof(g_conns); i := i + 1) {
						CLIENT.send(ud.pdu) to g_conns[i].vc_conn;
					}
				}
			}

		[] CLIENT.receive(PDU_PFCP:?) -> value pdu sender vc_conn {
				log("PFCP_Emulation main() CLIENT.receive from ", vc_conn, ": ", pdu);
				if (pdu.sequence_number == 0) {
					pdu.sequence_number := f_PFCPEM_next_sequence_nr();
				}
				ud := {
					peer := {
						conn_id := g_pfcp_conn_id,
						remote_name := g_pfcp_cfg.pfcp_remote_ip,
						remote_port := g_pfcp_cfg.pfcp_remote_port
					},
					pdu := pdu
				};

				f_PFCPEM_conn_add_or_update({vc_conn, pdu.seid, pdu.sequence_number});

				PFCP.send(ud);
			}

		[] CLIENT_PROC.getcall(PFCPEM_register:{}) -> sender vc_conn {
				log("PFCP_Emulation main() CLIENT_PROC.getcall(PFCPEM_register)");
				f_PFCPEM_conn_add_or_update({vc_conn, omit, omit});
				CLIENT_PROC.reply(PFCPEM_register:{}) to vc_conn;
			}

		[] CLIENT_PROC.getcall(PFCPEM_get_recovery_timestamp:{?}) -> sender vc_conn {
				log("PFCP_Emulation main() CLIENT_PROC.getcall(PFCPEM_get_recovery_timestamp)");
				CLIENT_PROC.reply(PFCPEM_get_recovery_timestamp:{g_recovery_timestamp}) to vc_conn;
			}
		}
	}
}


/***********************************************************************
 * Interaction between Main and Client Components
 ***********************************************************************/
type port PFCPEM_PT message {
	inout PDU_PFCP;
} with { extension "internal" };

signature PFCPEM_register();
signature PFCPEM_get_recovery_timestamp(out integer rts);

type port PFCPEM_PROC_PT procedure {
	inout PFCPEM_register;
	inout PFCPEM_get_recovery_timestamp;
} with { extension "internal" };

/***********************************************************************
 * Client Component
 ***********************************************************************/

type component PFCP_ConnHdlr {
	port PFCPEM_PT PFCP;
	port PFCPEM_PROC_PT PFCP_PROC;
};

function f_pfcp_register() runs on PFCP_ConnHdlr {
	PFCP_PROC.call(PFCPEM_register:{}) {
		[] PFCP_PROC.getreply(PFCPEM_register:{});
	}
}

function f_pfcp_get_recovery_timestamp()
runs on PFCP_ConnHdlr return integer {
	var integer rts;

	PFCP_PROC.call(PFCPEM_get_recovery_timestamp:{-}) {
		[] PFCP_PROC.getreply(PFCPEM_get_recovery_timestamp:{?}) -> param(rts) {};
	}

	return rts;
}

altstep as_pfcp_ignore(PFCPEM_PT pt, template PDU_PFCP pfcp_expect := ?)
{
	[] pt.receive(pfcp_expect) {
		log("Ignoring ", pfcp_expect);
		repeat;
	}
}

}
