/* NS Provider for NS/FR/E1
 * (C) 2020 Harald Welte <laforge@gnumonks.org>
 * contributions by sysmocom - s.f.m.c. GmbH
 * All rights reserved.
 *
 * Released under the terms of GNU General Public License, Version 2 or
 * (at your option) any later version.
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 */

module NS_Provider_FR {

import from NS_Emulation all;
import from NS_Types all;

import from AF_PACKET_PortType all;
import from FrameRelay_Types all;
import from FrameRelay_Emulation all;


type component NS_Provider_FR_CT extends NS_Provider_CT, FR_Client_CT {
	/* component reference to Frame Relay emulation */
	var FR_Emulation_CT vc_FREMU;
};

function main(NSConfiguration config) runs on NS_Provider_FR_CT system af_packet {

	/* start Frame Relay Emulation */
	vc_FREMU := FR_Emulation_CT.create();
	var Q933em_Config q933_cfg := valueof(ts_Q933em_Config(ats_is_user := not config.role_sgsn, bidirectional := false));
	map(vc_FREMU:FR, system:AF_PACKET) param (config.provider.fr.netdev);
	vc_FREMU.start(FrameRelay_Emulation.main(q933_cfg));

	/* connect ourselves to frame relay emulation */
	connect(self:FR, vc_FREMU:CLIENT);
	connect(self:FR_PROC, vc_FREMU:PROC);

	/* register ourselves for the specified DLCI */
	f_fremu_register(config.provider.fr.dlci);

	/* transceive between user-facing port and FR socket */
	while (true) {
		var FrameRelayFrame rx_fr;
		var FRemu_Event rx_frevt;
		var PDU_NS rx_pdu;
		alt {

		[] FR.receive(FrameRelayFrame:?) -> value rx_fr {
			NSE.send(dec_PDU_NS(rx_fr.payload));
			}

		[] FR.receive(FRemu_Event:?) -> value rx_frevt {
			/* TODO: dispatch to user */
			}
		[] NSE.receive(PDU_NS:?) -> value rx_pdu {
			FR.send(ts_FR(config.provider.fr.dlci, enc_PDU_NS(rx_pdu), true));
			}

		}
	}

} /* main */



} /* module */
