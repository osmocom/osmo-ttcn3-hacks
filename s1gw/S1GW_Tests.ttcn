/* OsmoS1GW (S1AP Gateway) test suite in TTCN-3
 *
 * (C) 2024 by sysmocom - s.f.m.c. GmbH <info@sysmocom.de>
 * Author: Vadim Yanitskiy <vyanitskiy@sysmocom.de>
 *
 * All rights reserved.
 *
 * Released under the terms of GNU General Public License, Version 2 or
 * (at your option) any later version.
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 */

module S1GW_Tests {

import from General_Types all;
import from Osmocom_Types all;
import from Native_Functions all;
import from IPL4asp_Types all;
import from Misc_Helpers all;

import from S1AP_CodecPort all;
import from S1AP_CodecPort_CtrlFunct all;
import from S1AP_Types all;
import from S1AP_Templates all;
import from S1AP_PDU_Descriptions all;
import from S1AP_IEs all;
import from S1AP_PDU_Contents all;
import from S1AP_Constants all;

import from PFCP_Types all;
import from PFCP_Emulation all;
import from PFCP_Templates all;
import from PFCP_CodecPort all;

import from SCTP_Templates all;

import from StatsD_Types all;
import from StatsD_CodecPort all;
import from StatsD_CodecPort_CtrlFunct all;
import from StatsD_Checker all;

import from S1AP_Server all;
import from S1GW_ConnHdlr all;

modulepar {
	charstring mp_s1gw_enb_ip := "127.0.1.1";	/* eNB facing address of the S1GW */
	charstring mp_enb_bind_ip := "127.0.1.10";	/* eNB address to use locally when connecting to S1GW */
	charstring mp_s1gw_mme_ip := "127.0.2.1";	/* MME facing address of the S1GW */
	charstring mp_mme_bind_ip := "127.0.2.10";	/* MME address on which we get connections from S1GW */
	charstring mp_s1gw_upf_ip := "127.0.3.1";	/* UPF facing address of the S1GW */
	charstring mp_upf_bind_ip := "127.0.3.10";	/* UPF address on which we get connections from S1GW */

	/* Our emulated StatsD server: */
	charstring mp_local_statsd_ip := "127.0.4.10";
	integer mp_local_statsd_port := 8125;
	charstring mp_statsd_prefix := "s1gw.";
}

type component test_CT extends StatsD_Checker_CT {
	timer g_Tguard;
	var S1AP_Server_CT vc_S1APSRV;
	var PFCP_Emulation_CT vc_PFCP;
	var StatsD_Checker_CT vc_STATSD;
};

private altstep as_Tguard() runs on test_CT {
	[] g_Tguard.timeout {
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail, "Tguard timeout");
	}
}

function f_init(boolean s1apsrv_start := true,
		boolean upf_start := true,
		float Tval := 20.0) runs on test_CT {
	g_Tguard.start(Tval);
	activate(as_Tguard());

	f_init_statsd("StatsDSRV", vc_STATSD, mp_local_statsd_ip, mp_local_statsd_port);

	if (s1apsrv_start) {
		f_init_s1ap_srv();
	}
	if (upf_start) {
		f_init_pfcp();
	}
}

function f_init_s1ap_srv() runs on test_CT {
	var S1APSRV_ConnParams cpars := {
		local_ip := mp_mme_bind_ip,
		local_port := 36412
	};

	vc_S1APSRV := S1AP_Server_CT.create("S1APSRV-" & testcasename()) alive;
	vc_S1APSRV.start(S1AP_Server.main(cpars));
}

function f_init_pfcp() runs on test_CT {
	var PFCP_Emulation_Cfg pfcp_cfg := {
		pfcp_bind_ip := mp_upf_bind_ip,
		pfcp_bind_port := PFCP_PORT,
		pfcp_remote_ip := mp_s1gw_upf_ip,
		pfcp_remote_port := PFCP_PORT,
		role := UPF
	};

	vc_PFCP := PFCP_Emulation_CT.create("PFCP-" & testcasename()) alive;
	vc_PFCP.start(PFCP_Emulation.main(pfcp_cfg));
}

function f_new_ConnHdlrPars(integer idx := 0) return ConnHdlrPars {
	var ConnHdlrPars pars := valueof(t_ConnHdlrPars(idx, mp_statsd_prefix));
	return pars;
}

function f_ConnHdlr_spawn(void_fn fn, ConnHdlrPars pars)
runs on test_CT return ConnHdlr {
	var ConnHdlr vc_conn;
	var charstring id := "ConnHdlr-" & testcasename() & "-" & int2str(pars.idx);

	vc_conn := ConnHdlr.create(id) alive;
	if (isbound(vc_STATSD) and vc_STATSD.running) {
		connect(vc_conn:STATSD_PROC, vc_STATSD:STATSD_PROC);
	}
	if (isbound(vc_S1APSRV) and vc_S1APSRV.running) {
		connect(vc_conn:S1AP_CONN, vc_S1APSRV:S1AP_CLIENT);
		connect(vc_conn:S1AP_PROC, vc_S1APSRV:S1AP_PROC);
	}
	if (isbound(vc_PFCP) and vc_PFCP.running) {
		connect(vc_conn:PFCP, vc_PFCP:CLIENT);
		connect(vc_conn:PFCP_PROC, vc_PFCP:CLIENT_PROC);
	}
	vc_conn.start(f_ConnHdlr_init(fn, id, pars));

	return vc_conn;
}

function f_TC_setup(charstring id) runs on ConnHdlr {
	f_ConnHdlr_register_pfcp();
	f_ConnHdlr_s1ap_register(g_pars.genb_id);

	/* Expected values relative to snapshot: */
	var StatsDExpects statsd_exp := {
		{name := mp_statsd_prefix & "gauge.s1ap.enb.num_sctp_connections.value", mtype := "g", min := 1, max := 1},
		{name := mp_statsd_prefix & "ctr.s1ap.proxy.in_pkt.unmodified.value", mtype := "c", min := 2, max := 2}
	}
	var StatsDMetrics statsd_snapshot := f_statsd_snapshot(f_statsd_keys_from_expect(statsd_exp));

	f_ConnHdlr_s1ap_connect(mp_enb_bind_ip, mp_s1gw_enb_ip);
	f_ConnHdlr_s1ap_setup(g_pars.genb_id);
	f_sleep(0.5); /* keep the connection idle for some time */

	f_statsd_expect_from_snapshot(statsd_exp, wait_converge := true, snapshot := statsd_snapshot);

	f_ConnHdlr_s1ap_disconnect();

	/* Validate gauge decreases when we disconnect: */
	f_statsd_expect({{name := mp_statsd_prefix & "gauge.s1ap.enb.num_sctp_connections.value", mtype := "g", min := 0, max := 0}},
			wait_converge := true);

	f_ConnHdlr_s1ap_unregister(g_pars.genb_id);
}
testcase TC_setup() runs on test_CT {
	var ConnHdlrPars pars := f_new_ConnHdlrPars();
	var ConnHdlr vc_conn;

	f_init();

	vc_conn := f_ConnHdlr_spawn(refers(f_TC_setup), pars);
	vc_conn.done;
}

function f_TC_setup_multi(charstring id) runs on ConnHdlr {
	f_ConnHdlr_register_pfcp();
	f_ConnHdlr_s1ap_register(g_pars.genb_id);

	f_ConnHdlr_s1ap_connect(mp_enb_bind_ip, mp_s1gw_enb_ip);
	f_ConnHdlr_s1ap_setup(g_pars.genb_id);
	f_sleep(0.5); /* keep the connection idle for some time */

	f_ConnHdlr_s1ap_disconnect();

	f_ConnHdlr_s1ap_unregister(g_pars.genb_id);
}
testcase TC_setup_multi() runs on test_CT {
	var ConnHdlrList vc_conns := { };

	f_init();

	for (var integer i := 0; i < 42; i := i + 1) {
		var ConnHdlrPars pars := f_new_ConnHdlrPars(i);
		var ConnHdlr vc_conn := f_ConnHdlr_spawn(refers(f_TC_setup_multi), pars);
		vc_conns := vc_conns & { vc_conn };
	}

	for (var integer i := 0; i < 42; i := i + 1) {
		vc_conns[i].done;
	}
}


/* MME terminates connection, expect S1GW to terminate the eNB connection */
function f_TC_conn_term_by_mme(charstring id) runs on ConnHdlr {
	f_ConnHdlr_register_pfcp();
	f_ConnHdlr_s1ap_register(g_pars.genb_id);

	f_ConnHdlr_s1ap_connect(mp_enb_bind_ip, mp_s1gw_enb_ip);
	f_ConnHdlr_s1ap_setup(g_pars.genb_id);
	f_sleep(0.5); /* keep the connection idle for some time */

	/* MME (S1AP_Server_CT) terminates connection */
	f_ConnHdlr_s1ap_close_conn(g_pars.genb_id);
	/* expect our eNB connection to be released gracefully */
	f_ConnHdlr_s1ap_expect_shutdown();

	f_ConnHdlr_s1ap_unregister(g_pars.genb_id);
}
testcase TC_conn_term_by_mme() runs on test_CT {
	var ConnHdlrPars pars := f_new_ConnHdlrPars();
	var ConnHdlr vc_conn;

	f_init();

	vc_conn := f_ConnHdlr_spawn(refers(f_TC_conn_term_by_mme), pars);
	vc_conn.done;
}


/* MME is not available, expect S1GW to terminate the eNB connection */
function f_TC_conn_term_mme_unavail(charstring id) runs on ConnHdlr {
	f_ConnHdlr_register_pfcp();
	/* establish an eNB connection to the S1GW */
	f_ConnHdlr_s1ap_connect(mp_enb_bind_ip, mp_s1gw_enb_ip);
	/* expect our eNB connection to be released gracefully */
	f_ConnHdlr_s1ap_expect_shutdown();
	setverdict(pass);
}
testcase TC_conn_term_mme_unavail() runs on test_CT {
	var ConnHdlrPars pars := f_new_ConnHdlrPars();
	var ConnHdlr vc_conn;

	f_init(s1apsrv_start := false);

	vc_conn := f_ConnHdlr_spawn(refers(f_TC_conn_term_mme_unavail), pars);
	vc_conn.done;
}

function f_TC_e_rab_setup(charstring id) runs on ConnHdlr {
	const integer mme_id := 7;
	const integer enb_id := 9;
	const integer erab_id := 6;
	var S1AP_PDU pdu;

	f_ConnHdlr_register_pfcp();
	f_ConnHdlr_s1ap_register(g_pars.genb_id);
	f_ConnHdlr_s1ap_connect(mp_enb_bind_ip, mp_s1gw_enb_ip);
	f_ConnHdlr_s1ap_setup(g_pars.genb_id);

	log("eNB <- [S1GW] <- MME: E-RAB SETUP REQUEST");
	var template (value) E_RABToBeSetupListBearerSUReq items_req;
	var E_RABToBeSetupItemBearerSUReq item_req := {
		e_RAB_ID := erab_id,
		e_RABlevelQoSParameters := {
			qCI := 5,
			allocationRetentionPriority := {
				priorityLevel := 1,
				pre_emptionCapability := shall_not_trigger_pre_emption,
				pre_emptionVulnerability := not_pre_emptable,
				iE_Extensions := omit
			},
			gbrQosInformation := omit,
			iE_Extensions := omit
		},
		transportLayerAddress := -,
		gTP_TEID := f_rnd_octstring(4),
		nAS_PDU := ''O,
		iE_Extensions := omit
	};

	/* MME -> S1GW */
	item_req.transportLayerAddress := oct2bit(f_inet_addr("1.2.3.4"));
	items_req := ts_S1AP_RABToBeSetupListBearerSUReq(item_req);
	f_ConnHdlr_tx_s1ap_from_mme(ts_S1AP_RABSetupReq(mme_id, enb_id, items_req));

	/* S1GW -> eNB */
	item_req.transportLayerAddress := oct2bit(f_inet_addr(mp_s1gw_mme_ip));
	items_req := ts_S1AP_RABToBeSetupListBearerSUReq(item_req);
	f_ConnHdlr_rx_s1ap_from_mme(pdu, tr_S1AP_RABSetupReq(mme_id, enb_id, items_req));


	log("eNB -> [S1GW] -> MME: E-RAB SETUP RESPONSE");
	var template (value) E_RABSetupListBearerSURes items_res;
	var E_RABSetupItemBearerSURes item_res := {
		e_RAB_ID := erab_id,
		transportLayerAddress := -,
		gTP_TEID := f_rnd_octstring(4),
		iE_Extensions := omit
	};

	/* eNB -> S1GW */
	item_res.transportLayerAddress := oct2bit(f_inet_addr("4.3.2.1"));
	items_res := ts_S1AP_RABSetupListBearerSURes(item_res);
	f_ConnHdlr_tx_s1ap_from_enb(ts_S1AP_RABSetupRsp(mme_id, enb_id, items_res));

	/* S1GW -> MME */
	item_res.transportLayerAddress := oct2bit(f_inet_addr(mp_s1gw_enb_ip));
	items_res := ts_S1AP_RABSetupListBearerSURes(item_res);
	f_ConnHdlr_rx_s1ap_from_enb(pdu, tr_S1AP_RABSetupRsp(mme_id, enb_id, items_res));

	f_ConnHdlr_s1ap_disconnect();
	f_ConnHdlr_s1ap_unregister(g_pars.genb_id);
}
testcase TC_e_rab_setup() runs on test_CT {
	var ConnHdlrPars pars := f_new_ConnHdlrPars();
	var ConnHdlr vc_conn;

	f_init();

	vc_conn := f_ConnHdlr_spawn(refers(f_TC_e_rab_setup), pars);
	vc_conn.done;
}

control {
	execute( TC_setup() );
	execute( TC_setup_multi() );
	execute( TC_conn_term_by_mme() );
	execute( TC_conn_term_mme_unavail() );
	execute( TC_e_rab_setup() );
}

}
