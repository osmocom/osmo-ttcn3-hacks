/* OsmoS1GW (S1AP Gateway) ConnHdlr
 *
 * (C) 2024 by sysmocom - s.f.m.c. GmbH <info@sysmocom.de>
 * Author: Vadim Yanitskiy <vyanitskiy@sysmocom.de>
 *
 * All rights reserved.
 *
 * Released under the terms of GNU General Public License, Version 2 or
 * (at your option) any later version.
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 */

module S1GW_ConnHdlr {

import from General_Types all;
import from Osmocom_Types all;
import from Native_Functions all;
import from IPL4asp_Types all;
import from Misc_Helpers all;

import from PFCP_Types all;
import from PFCP_Emulation all;
import from PFCP_Templates all;
import from PFCP_CodecPort all;

import from S1AP_CodecPort all;
import from S1AP_CodecPort_CtrlFunct all;
import from S1AP_Types all;
import from S1AP_Templates all;
import from S1AP_PDU_Descriptions all;
import from S1AP_IEs all;
import from S1AP_PDU_Contents all;
import from S1AP_Constants all;

import from SCTP_Templates all;

import from StatsD_Types all;
import from StatsD_Checker all;

import from S1AP_Server all;

type component ConnHdlr extends S1APSRV_ConnHdlr, PFCP_ConnHdlr, StatsD_ConnHdlr {
	var ConnHdlrPars g_pars;
	port S1AP_CODEC_PT S1AP_ENB;
	var ConnectionId g_s1ap_conn_id := -1;
	var integer g_pfcp_recovery_timestamp := -1;
};
type record of ConnHdlr ConnHdlrList;

type record ConnHdlrPars {
	integer idx,
	Global_ENB_ID genb_id,
	charstring statsd_prefix
};

template Global_ENB_ID
ts_Global_ENB_ID(integer enb_id := 0,
		 OCT3 plmn_id := '00f110'O) := {
	pLMNidentity := plmn_id,
	eNB_ID := {
		macroENB_ID := int2bit(enb_id, 20)
	},
	iE_Extensions := omit
}

template (value) ConnHdlrPars
t_ConnHdlrPars(integer idx := 0, charstring statsd_prefix := "") := {
	idx := idx,
	genb_id := ts_Global_ENB_ID(idx),
	statsd_prefix := statsd_prefix
}

type function void_fn(charstring id) runs on ConnHdlr;

function f_ConnHdlr_init(void_fn fn, charstring id, ConnHdlrPars pars)
runs on ConnHdlr {
	g_pars := pars;
	fn.apply(id);
}


function f_ConnHdlr_s1ap_connect(charstring local_addr, charstring remote_addr) runs on ConnHdlr {
	var Result res;
	timer T;

	map(self:S1AP_ENB, system:S1AP_CODEC_PT);

	/* initiate SCTP connection establishment */
	res := S1AP_CodecPort_CtrlFunct.f_IPL4_connect(S1AP_ENB,
						       remote_addr, 36412,
						       local_addr, 0, -1,
						       { sctp := c_SctpTuple_S1AP });
	if (not ispresent(res.connId)) {
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail,
					"Could not create an S1AP socket, check your configuration");
	}
	g_s1ap_conn_id := res.connId;

	/* wait for the establishment confirmation */
	T.start(2.0);
	alt {
	[] S1AP_ENB.receive(tr_SctpAssocChange(SCTP_COMM_UP, g_s1ap_conn_id)) {
		log("eNB connection established");
		}
	[] S1AP_ENB.receive(PortEvent:{sctpEvent := ?}) { repeat; }
	[] T.timeout {
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail,
					"eNB connection establishment timeout");
		}
	}
}

function f_ConnHdlr_s1ap_disconnect() runs on ConnHdlr {
	var Result res;

	S1AP_CodecPort_CtrlFunct.f_IPL4_close(S1AP_ENB, g_s1ap_conn_id,
					      { sctp := c_SctpTuple_S1AP });
	g_s1ap_conn_id := -1;
	unmap(self:S1AP_ENB, system:S1AP_CODEC_PT);

	S1AP_CONN.receive(S1APSRV_Event:S1APSRV_EVENT_CONN_DOWN);

	log("eNB connection closed");
}

function f_ConnHdlr_s1ap_expect_shutdown() runs on ConnHdlr {
	S1AP_ENB.receive(tr_SctpShutDownEvent(g_s1ap_conn_id));
	S1AP_ENB.receive(tr_SctpAssocChange(SCTP_SHUTDOWN_COMP, g_s1ap_conn_id));
	S1AP_ENB.receive(PortEvent:{connClosed := ?});
}

function f_ConnHdlr_tx_s1ap_from_enb(template (value) S1AP_PDU pdu)
runs on ConnHdlr {
	S1AP_ENB.send(t_S1AP_Send(g_s1ap_conn_id, pdu));
}

function f_ConnHdlr_tx_s1ap_from_mme(template (value) S1AP_PDU pdu)
runs on ConnHdlr {
	S1AP_CONN.send(pdu);
}

function f_ConnHdlr_rx_s1ap_from_enb(out S1AP_PDU pdu,
				     template (present) S1AP_PDU tr_pdu := ?,
				     float Tval := 3.0)
runs on ConnHdlr {
	timer T := Tval;

	T.start;
	alt {
	[] S1AP_CONN.receive(tr_pdu) -> value pdu {
		setverdict(pass);
		T.stop;
		}
	[] S1AP_CONN.receive(S1AP_PDU:?) -> value pdu {
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail,
					log2str("Rx unexpected S1AP PDU from eNB: ", pdu));
		}
	[] T.timeout {
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail,
					log2str("Timeout waiting for S1AP PDU from eNB: ", tr_pdu));
		}
	}
}

function f_ConnHdlr_rx_s1ap_from_mme(out S1AP_PDU pdu,
				     template (present) S1AP_PDU tr_pdu := ?,
				     float Tval := 3.0)
runs on ConnHdlr {
	var S1AP_RecvFrom recv;
	timer T := Tval;

	T.start;
	alt {
	[] S1AP_ENB.receive(t_S1AP_RecvFrom(tr_pdu)) -> value recv {
		pdu := recv.msg;
		setverdict(pass);
		T.stop;
		}
	[] S1AP_ENB.receive(t_S1AP_RecvFrom(?)) -> value recv {
		pdu := recv.msg;
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail,
					log2str("Rx unexpected S1AP PDU from MME: ", pdu));
		}
	[] T.timeout {
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail,
					log2str("Timeout waiting for S1AP PDU from MME: ", tr_pdu));
		}
	}
}

function f_ConnHdlr_s1ap_setup(Global_ENB_ID genb_id, float Tval := 5.0) runs on ConnHdlr {
	var S1AP_PDU pdu;
	timer T;

	var SupportedTAs supported_tas_dummy := {
		{
			tAC := '0000'O,
			broadcastPLMNs := { '00f000'O },
			iE_Extensions := omit
		}
	};

	f_ConnHdlr_tx_s1ap_from_enb(ts_S1AP_SetupReq(genb_id,
						     supported_tas_dummy,
						     v32));
	T.start(Tval);
	alt {
	[] S1AP_CONN.receive(S1APSRV_Event:S1APSRV_EVENT_CONN_UP) { repeat; }
	[] S1AP_CONN.receive(tr_S1AP_SetupReq) {
		var template (value) PLMNidentity plmn_id := '00f110'O;
		var template (value) MME_Group_ID mme_group_id := '0011'O;
		var template (value) MME_Code mme_code := '55'O;
		var template (value) ServedGUMMEIsItem gummei := ts_S1AP_ServedGUMMEIsItem(
			{ plmn_id },
			{ mme_group_id },
			{ mme_code }
		);
		f_ConnHdlr_tx_s1ap_from_mme(ts_S1AP_SetupResp({ gummei }, 1));
		f_ConnHdlr_rx_s1ap_from_mme(pdu, tr_S1AP_SetupResp({ gummei }, 1));
		T.stop;
		}
	[] S1AP_CONN.receive(S1AP_PDU:?) -> value pdu {
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail,
					log2str("Rx unexpected S1AP PDU: ", pdu));
		}
	[] T.timeout {
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail,
					log2str("Timeout waiting for S1AP SetupReq, idx = ", g_pars.idx));
		}
	}
}

private function f_pfcp_handle_assoc_setup_req()
runs on ConnHdlr
{
	var PDU_PFCP rx;

	rx := f_ConnHdlr_pfcp_expect(tr_PFCP_Assoc_Setup_Req, Tval := 10.0);
	PFCP.send(ts_PFCP_Assoc_Setup_Resp(rx.sequence_number,
					   ts_PFCP_Node_ID_fqdn("\07osmocom\03org"),
					   ts_PFCP_Cause(REQUEST_ACCEPTED),
					   1234)); /* FIXME: request the value from PFCPEM */
}

function f_ConnHdlr_pfcp_expect(template (present) PDU_PFCP exp_rx := ?,
				float Tval := 2.0)
runs on ConnHdlr return PDU_PFCP
{
	var PDU_PFCP pdu;
	timer T;

	T.start(Tval);
	alt {
	[] PFCP.receive(exp_rx) -> value pdu { T.stop; }
	[] PFCP.receive(PDU_PFCP:?) -> value pdu {
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail,
					log2str("Got an unexpected PFCP PDU: ", pdu));
		}
	[] T.timeout {
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__, fail,
					log2str("Timeout waiting for PFCP ", exp_rx));
		}
	}

	return pdu;
}

function f_ConnHdlr_register_pfcp() runs on ConnHdlr
{
	f_pfcp_register();
	g_pfcp_recovery_timestamp := f_pfcp_get_recovery_timestamp();

	/* First ConnHdlr answers the AssocSetup: */
	if (g_pars.idx != 0) {
		activate(as_pfcp_ignore(PFCP, tr_PFCP_Assoc_Setup_Req()));
		return;
	}

	var StatsDMetricKeys statsd_keys := {
		valueof(ts_StatsDMetricKey(g_pars.statsd_prefix & "gauge.pfcp.associated.value", "g"))
	};
	var StatsDMetrics statsd_snapshot := f_statsd_snapshot(statsd_keys, since_last_snapshot := false);
	var boolean pfcp_associated := statsd_snapshot[0].val == 1;

	if (not pfcp_associated) {
		log("Waiting for IUT to associate over PFCP");
		f_pfcp_handle_assoc_setup_req();
	}
}
}
