///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Copyright Test Competence Center (TCC) ETH 2008                           //
//                                                                           //
// The copyright to the computer  program(s) herein  is the property of TCC. //
// The program(s) may be used and/or copied only with the written permission //
// of TCC or in accordance with  the terms and conditions  stipulated in the //
// agreement/contract under which the program(s) have been supplied          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
//  File:         SCCP_Emulation.ttcn
//  Description:  SS7 SCCP definitions and dynamic part according to
//                 specification ITU-T SS7 SCCP, ANSI ..., ttc ...
//  References:   ITU-T: Recommendation Q.711-Q.714,
//                ANSI : T1.111-2001 (MTP) and T1.112-2001 (SCCP)
//                TTC  : JT-Q711
//  Rev:          R6A05
//  Prodnr:       CNL 113 341
//  Updated:      2009-01-26
//  Contact:      http://ttcn.ericsson.se

module SCCP_Emulation
{//startmodule

modulepar
{
  float   tsp_maxLocalReference := 16777216.0;  //loc ref= 0...tsp_maxLocalReference-1
  float   tsp_max_ConnectionId  := 16777216.0;  //max connection id = 0..tsp_max_ConnectionId -1
  integer tsp_force_xudt := 0;
  integer tsp_SIF_MaxLength := 272
}

import from General_Types all;
import from MTP3asp_Types all;
import from MTP3asp_PortType all;
import from SCCP_Types  all;
import from SCCPasp_Types all;
import from SCCP_Mapping all;

group   SCCPConstants
{//startgroup SCCPConstants

//------------------------------------------------------------------------------
// Subsystem Numbers
//------------------------------------------------------------------------------

const integer cg_SSN_notKnown:=0;
const integer cg_SSN_sCCPmanagement:=1;
const integer cg_SSN_reservedForITU:=2;
const integer cg_SSN_iSUP:=3;
const integer cg_SSN_oMAP:=4;
const integer cg_SSN_mAP:=5;
const integer cg_SSN_hLR:=6;
const integer cg_SSN_vLR:=7;
const integer cg_SSN_mSC:=8;
const integer cg_SSN_eIC:=9;
const integer cg_SSN_aUC:=10;
const integer cg_SSN_isdnSS:=11;
const integer cg_SSN_reservedForIntUse:=12;
const integer cg_SSN_bISDNe2e:=13;
const integer cg_SSN_tCtestResponder:=14;
const integer cg_SSN_rANAP:=142;
const integer cg_SSN_bSSAP:=254;
// TCAP has not SSN

//------------------------------------------------------------------------------
// Routing Indicator values ITU: 3.4.1/Q713.
//------------------------------------------------------------------------------
const BIT1n cg_route_on_SSN := '1'B;
const BIT1n cg_route_on_GT := '0'B;

//------------------------------------------------------------------------------
// Release Cause
//------------------------------------------------------------------------------


const integer cg_Rel_endUserOrig:=0;
const integer cg_Rel_endUserCong:=1;
const integer cg_Rel_endUserFailure:=2;
const integer cg_Rel_sCCPUserOrig:=3;
const integer cg_Rel_remProcError:=4;
const integer cg_Rel_inconsConnData:=5;
const integer cg_Rel_accessFailure:=6;
const integer cg_Rel_accessCongestion:=7;
const integer cg_Rel_subsystFailure:=8;
const integer cg_Rel_subsystCongest:=9;
const integer cg_Rel_mTPFailure:=10;
const integer cg_Rel_networkCongest:=11;
const integer cg_Rel_expResetTimer:=12;
const integer cg_Rel_expRecInacTimer:=13;
const integer cg_Rel_reserved:=14;
const integer cg_Rel_unqualified:=15;
const integer cg_Rel_sCCPFailure:=16;

//------------------------------------------------------------------------------
// Return Cause
//------------------------------------------------------------------------------

const integer cg_Ret_noTransl4AddrNature:=0;
const integer cg_Ret_noTransl4SpecifAddr:=1;
const integer cg_Ret_subsystemCongestion:=2;
const integer cg_Ret_subsystemFailure:=3;
const integer cg_Ret_unequippedUser:=4;
const integer cg_Ret_mTPFailure:=5;
const integer cg_Ret_networkCongestion:=6;
const integer cg_Ret_unqualified:=7;
const integer cg_Ret_errorMessageTransport:=8;
const integer cg_Ret_errorLocalProcessing:=9;
const integer cg_Ret_destNoReassembly:=10;
const integer cg_Ret_sCCPFailure:=11;
const integer cg_Ret_hopCounterViolation:=12;
const integer cg_Ret_segmeNotSupported:=13;
const integer cg_Ret_segmentationFailure:=14;

//------------------------------------------------------------------------------
// Reset Cause
//------------------------------------------------------------------------------


const integer cg_Res_endUserOrig:=0;
const integer cg_Res_sCCPUserOrig:=1;
const integer cg_Res_messOutOfOrder_incPs:=2;
const integer cg_Res_messOutOfOrder_incPr:=3;
const integer cg_Res_remProcErr_messOutOfWindow:=4;
const integer cg_Res_remProcErr_IncPsAfterReinit:=5;
const integer cg_Res_remProcErr_general:=6;
const integer cg_Res_remEndUserOperational:=7;
const integer cg_Res_networkOperational:=8;
const integer cg_Res_accessOperational:=9;
const integer cg_Res_networkCongestion:=10;
const integer cg_Res_reserved:=11;
const integer cg_Res_unqualified:=12;

//------------------------------------------------------------------------------
//Error Cause
//------------------------------------------------------------------------------

const integer cg_Err_unassignedDestinationLRN:=0 ;
const integer cg_Err_inconsistentSourceLRN:=1 ;
const integer cg_Err_pointCodeMismatch:=2 ;
const integer cg_Err_serviceClassMismatch:=3 ;
const integer cg_Err_unqualified:=4 ;

//------------------------------------------------------------------------------
//Refusal  Cause
//------------------------------------------------------------------------------

const integer cg_Ref_endUserOrigin:=0;
const integer cg_Ref_endUserConges:=1;
const integer cg_Ref_endUserFailure:=2;
const integer cg_Ref_sCCPUserOrigin:=3;
const integer cg_Ref_destAddrUnkn:=4;
const integer cg_Ref_destInaccess:=5;
const integer cg_Ref_qOSNotAvail_nonTransient:=6;
const integer cg_Ref_qOSNotAvail_transient:=7;
const integer cg_Ref_accessFailure:=8;
const integer cg_Ref_accessCongestion:=9;
const integer cg_Ref_subsystemFailure:=10;
const integer cg_Ref_subsystemCongest:=11;
const integer cg_Ref_expConnEstTimer:=12;
const integer cg_Ref_incomUserData:=13;
const integer cg_Ref_reserved:=14;
const integer cg_Ref_unqualified:=15;
const integer cg_Ref_hopCounterViol:=16;
const integer cg_Ref_sCCPFailure:=17;
const integer cg_Ref_noTransl4address:=18;
const integer cg_Ref_unequippedUser:=19;

//------------------------------------------------------------------------------
// Originator
//------------------------------------------------------------------------------

const integer cg_Undefined:=0;
const integer cg_NSU:=1;
const integer cg_NSP:=2;


//------------------------------------------------------------------------------
// CREF Reason
//------------------------------------------------------------------------------

const integer cg_CREF_endUserOrig:=0;
const integer cg_CREF_endUserCong:=1;
const integer cg_CREF_endUserFailure:=2;
const integer cg_CREF_SCCPUserOrig:=3;
const integer cg_CREF_destAddrUnknwn_NT:=4;
const integer cg_CREF_destInaccg_T:=5;
const integer cg_CREF_QOSUnavail_NT:=6;
const integer cg_CREF_QOSUnavail_T:=7;
const integer cg_CREF_accessFailure:=8;
const integer cg_CREF_accessCong:=9;
const integer cg_CREF_destInaccg_NT:=10;
const integer cg_CREF_subsystCong:=11;
const integer cg_CREF_unspec_T:=12;
const integer cg_CREF_incompInfo:=13;
const integer cg_CREF_unspec_NT:=15;
const integer cg_CREF_undef:=16;
const integer cg_CREF_hopCntrViolation:=18;

//------------------------------------------------------------------------------
// DISC Reason
//------------------------------------------------------------------------------

const integer cg_DISC_normal:=20;
const integer cg_DISC_endUserCong:=21;
const integer cg_DISC_endUserFailure:=22;
const integer cg_DISC_SCCPUserOrig:=23;
const integer cg_DISC_abnormal_T:=24;
const integer cg_DISC_accessFailure:=28;
const integer cg_DISC_accessCong:=29;
const integer cg_DISC_abnormal_NT:=30;
const integer cg_DISC_subsystCong:=31;
const integer cg_DISC_undef:=32;
const integer cg_DISC_incompInfo:=33;
const integer cg_DISC_abnormal:=35;

//------------------------------------------------------------------------------
// RESET Reason
//------------------------------------------------------------------------------
const integer cg_RESET_userSynch:= 40  ;
const integer cg_RESET_unspec:= 41  ;
const integer cg_RESET_netCong:= 42  ;
const integer cg_RESET_undef:= 43  ;

//------------------------------------------------------------------------------
//Mapping Refusal  Cause to Reason and Originator A.1/Q.713
//------------------------------------------------------------------------------

const integer cg_Mapping_RefCause_Orig[20]:=
{
  cg_NSU,
  cg_NSU,
  cg_NSU,
  cg_NSU,
  cg_NSP,
  cg_NSP,
  cg_NSP,
  cg_NSP,
  cg_NSU,
  cg_NSU,
  cg_NSP,
  cg_NSU,
  cg_NSP,
  cg_NSU,
  cg_NSP,
  cg_Undefined,
  cg_NSP,
  cg_Undefined,
  cg_NSP,
  cg_NSP
};


const integer cg_Mapping_RefCause_Reason[20]:=
{
  cg_CREF_endUserOrig,
  cg_CREF_endUserCong,
  cg_CREF_endUserFailure,
  cg_CREF_SCCPUserOrig,
  cg_CREF_destAddrUnknwn_NT,
  cg_CREF_destInaccg_T,
  cg_CREF_QOSUnavail_NT,
  cg_CREF_QOSUnavail_T,
  cg_CREF_accessFailure,
  cg_CREF_accessCong,
  cg_CREF_destInaccg_NT,
  cg_CREF_subsystCong,
  cg_CREF_unspec_T,
  cg_CREF_incompInfo,
  cg_CREF_unspec_T,
  cg_CREF_undef,
  cg_CREF_hopCntrViolation,
  cg_CREF_undef,
  cg_CREF_destAddrUnknwn_NT,
  cg_CREF_destInaccg_NT
};

//------------------------------------------------------------------------------
//Mapping Release  Cause to Reason and Originator A.2/Q.713
//------------------------------------------------------------------------------

const integer cg_Mapping_RelCause_Orig[17]:=
{
  cg_NSU,
  cg_NSU,
  cg_NSU,
  cg_NSU,
  cg_NSP,
  cg_NSP,
  cg_NSU,
  cg_NSU,
  cg_NSP,
  cg_NSU,
  cg_NSP,
  cg_NSP,
  cg_NSP,
  cg_NSP,
  cg_Undefined,
  cg_Undefined,
  cg_NSP
};

//mapping CREF-> ASP_SCCP_N_DISCONNECT_ind:
//Reason:=cg_Mapping_RefCause_Reason[RefCause];
//Originator:=cg_Mapping_RefCause_Orig[RefCause];


//mapping ASP_SCCP_N_DISCONNECT_req-> CREF:
//

const integer cg_Mapping_RelCause_Reason[17]:= {
  cg_DISC_normal,
  cg_DISC_endUserCong,
  cg_DISC_endUserFailure,
  cg_DISC_SCCPUserOrig,
  cg_DISC_abnormal_T,
  cg_DISC_abnormal_T,
  cg_DISC_accessFailure,
  cg_DISC_accessCong,
  cg_DISC_abnormal_NT,
  cg_DISC_subsystCong,
  cg_DISC_abnormal_NT,
  cg_DISC_abnormal_T,
  cg_DISC_abnormal_T,
  cg_DISC_abnormal_T,
  cg_DISC_undef,
  cg_DISC_undef,
  cg_DISC_abnormal_NT
};



//mapping RLSD-> ASP_SCCP_N_DISCONNECT_ind:
//Reason:=cg_Mapping_RelCause_Reason[RelCause];
//Originator:=cg_Mapping_RelCause_Orig[RelCause];

//mapping ASP_SCCP_N_DISCONNECT_req-> RLSD:
//


//------------------------------------------------------------------------------
//Mapping Reset  Cause to Reason and Originator A.2/Q.713
//------------------------------------------------------------------------------


const integer cg_Mapping_ResCause_Orig[12]:= {
  cg_NSU,
  cg_NSU,
  cg_NSP,
  cg_NSP,
  cg_NSP,
  cg_NSP,
  cg_NSP,
  cg_NSU,
  cg_NSP,
  cg_NSU,
  cg_NSP,
  cg_Undefined
};


const integer cg_Mapping_ResCause_Reason[12]:= {
  cg_RESET_userSynch,
  cg_RESET_userSynch,
  cg_RESET_unspec,
  cg_RESET_unspec,
  cg_RESET_unspec,
  cg_RESET_unspec,
  cg_RESET_unspec,
  cg_RESET_userSynch,
  cg_RESET_unspec,
  cg_RESET_userSynch,
  cg_RESET_netCong,
  cg_RESET_undef
};

//mapping RSR-> ASP_SCCP_N_DISCONNECT_ind:
//Reason:=cg_Mapping_ResCause_Reason[ResCause];
//Originator:=cg_Mapping_ResCause_Orig[ResCause];

//mapping ASP_SCCP_N_DISCONNECT_req-> RSR:
//

const integer cg_TimerArraySize := 16;

}//endgroup SCCPConstants

//******************************************************************************
// PDU templates
//******************************************************************************


group PDUTemplateDefinitionsSending
{



//******************************************************************************
// Message Connection Request (CR) (Q713 $4.2)
//******************************************************************************

//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template           PDU_SCCP_ConnectionRequest t_PDU_SCCP_ConnectionRequest
(
          SCCP_param_SourceLocalReference   pl_SLR,
          SCCP_param_ProtocolClass          pl_Proto_Class,
          SCCP_param_CPartyAddressEnc       pl_CalledAddress,
template  SCCP_param_Credit_opt             pl_credit,
template  SCCP_param_CPartyAddressEnc_opt   pl_CallingAddress  ,
template  SCCP_param_Data_opt               pl_Data,
template  SCCP_param_HopCounter_opt         pl_HopCntr,
template  SCCP_param_Importance_opt         pl_Imp,
template  SCCP_param_EndOfOptionalParams    pl_eop

):=
  {
    messageType:=cr,
    sourceLocRef:=pl_SLR,
    protClass:=pl_Proto_Class,
    pointer1:=2,
    pointer2:=0,
    calledPAddress:=pl_CalledAddress,
    optionalPart:=  {
      credit:=pl_credit,
      callingPAddress:=pl_CallingAddress,
      data:=pl_Data,
      hopCounter:=pl_HopCntr,
      importance:=pl_Imp
    },
    eop:=pl_eop
  }



//******************************************************************************
// Message Connection Confirm (CC) (Q713 $4.3)
//******************************************************************************

//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template          PDU_SCCP_ConnectionConfirm t_PDU_SCCP_ConnectionConfirm
(
         SCCP_param_DestLocalReference   pl_DLR,
         SCCP_param_SourceLocalReference pl_SLR,
         SCCP_param_ProtocolClass        pl_Proto_Class,
template SCCP_param_Credit_opt           pl_credit,
template SCCP_param_CPartyAddressEnc_opt pl_CalledAddress,
template SCCP_param_Data_opt             pl_Data,
template SCCP_param_Importance_opt       pl_Imp,
template SCCP_param_EndOfOptionalParams  pl_eop
):=
  {
    messageType:=cc,
    destLocRef:=pl_DLR,
    sourceLocRef:=pl_SLR,
    protClass:=pl_Proto_Class,
    pointer1:=1,
    optionalPart:=  {
          credit:=pl_credit,
          calledPAddress:=pl_CalledAddress,
          data:=pl_Data,
          importance:=pl_Imp
    },
    eop:=pl_eop
  }


//******************************************************************************
// Message Connection Refused (CREF) (Q713 $4.4)
//******************************************************************************

//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template  PDU_SCCP_ConnectionRefused t_PDU_SCCP_ConnectionRefused
(
          SCCP_param_DestLocalReference     pl_DLR,
          SCCP_param_RefusalCause           pl_RefCause,
template  SCCP_param_CPartyAddressEnc_opt   pl_CalledAddress,
template  SCCP_param_Data_opt               pl_Data,
template  SCCP_param_Importance_opt         pl_Imp,
template  SCCP_param_EndOfOptionalParams     pl_eop
):=
  {
   messageType:=cref,
   destLocRef:=pl_DLR,
   refusalCause:=pl_RefCause,
   pointer1:=1,
   optionalPart:=  {
          calledPAddress:=pl_CalledAddress,
          data:=pl_Data,
          importance:=pl_Imp
      },
   eop:=pl_eop
  }


//******************************************************************************
// Message Released (RLSD) (Q713 $4.5)
//******************************************************************************


//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template PDU_SCCP_Released t_PDU_SCCP_Released
(
         OCT3 pl_DLR,
         OCT3 pl_SLR,
         SCCP_param_ReleaseCause  pl_RelCause,
template SCCP_param_Data_opt pl_Data,
template SCCP_param_Importance_opt pl_Imp,
template SCCP_param_EndOfOptionalParams pl_eop
):=
  {
    messageType:=rlsd,
    destLocRef:=pl_DLR,
    sourceLocRef:=pl_SLR,
    releaseCause:=pl_RelCause,
    pointer1:=1,
    optionalPart:=  {
      data:=pl_Data,
      importance:=pl_Imp
    },
    eop:=pl_eop
  }

//******************************************************************************
// Message Release Complete (RLC) (Q713 $4.6)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template PDU_SCCP_ReleaseComplete  t_PDU_SCCP_ReleaseComplete
(
         OCT3 pl_DLR,
         OCT3 pl_SLR
):=
  {
    messageType:=rlc,
    destLocRef:=pl_DLR,
    sourceLocRef:=pl_SLR
  }



//******************************************************************************
// Message Data form 1 (DT1) (Q713 $4.7)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template           PDU_SCCP_DataForm1  t_PDU_SCCP_DataForm1
(
         OCT3 pl_DLR,
         SCCP_param_SegmentingReassembl pl_SegmReasm,
         SCCP_param_Data  pl_Data
):=
  {
    messageType:=dt1,
    destLocRef:=pl_DLR,
    segmentingReassembl:=pl_SegmReasm,
    pointer1:=1,
    data:=pl_Data
  }



//******************************************************************************
// Message Data form 2 (DT2) (Q713 $4.8)
//******************************************************************************
//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------

//******************************************************************************
// Message Data Acknowledgement (AK) (Q713 $4.9)
//******************************************************************************
//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------


//******************************************************************************
// Message Unitdata (UDT) (Q713 $4.10)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template          PDU_SCCP_Unitdata t_PDU_SCCP_Unitdata
(
  SCCP_param_ProtocolClass      pl_Proto_Class,
  SCCP_param_CPartyAddressEnc   pl_CalledAddress,
  SCCP_param_CPartyAddressEnc   pl_CallingAddress,
  SCCP_param_Data               pl_Data
):=
  {
    messageType :=udt,
    protClass   :=pl_Proto_Class,
    pointer1:=3,
    pointer2:=0,
    pointer3:=0,
    calledPAddress  := pl_CalledAddress,
    callingPAddress := pl_CallingAddress,
    data:=pl_Data
  }



//******************************************************************************
// Message Unitdata service (UDTS) (Q713 $4.11)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template          PDU_SCCP_UnitdataService  t_PDU_SCCP_UnitdataService
(
  SCCP_param_ReturnCause          pl_RetCause,
  SCCP_param_CPartyAddressEnc     pl_CalledAddress,
  SCCP_param_CPartyAddressEnc     pl_CallingAddress,
  SCCP_param_Data                 pl_Data
):=
  {
    messageType:=udts,
    returnCause:=pl_RetCause,
    pointer1:=3,
    pointer2:=0,
    pointer3:=0,
    calledPAddress:=pl_CalledAddress,
    callingPAddress:=pl_CallingAddress,
    data:=pl_Data
  }

//******************************************************************************
// Message Expedited Data (ED) (Q713 $4.12)
//******************************************************************************
//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------


//******************************************************************************
// Message Expedited Data Acknowledgement (EA) (Q713 $4.13)
//******************************************************************************
//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------

//******************************************************************************
// Message Reset Request (RSR) (Q713 $4.14)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template          PDU_SCCP_ResetRequest t_PDU_SCCP_ResetRequest
(
         SCCP_param_DestLocalReference        pl_DLR,
         SCCP_param_SourceLocalReference      pl_SLR,
         SCCP_param_ResetCause         pl_ResCause
):=
  {
    messageType:=rsr,
    destLocRef:=pl_DLR,
    sourceLocRef:=pl_SLR,
    resetCause:=pl_ResCause
  }


//******************************************************************************
// Message Reset Confirmation (RSC) (Q713 $4.15)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
  template  PDU_SCCP_ResetConfirm  t_PDU_SCCP_ResetConfirm
  (
    SCCP_param_DestLocalReference        pl_DLR,
    SCCP_param_SourceLocalReference      pl_SLR
  ):=
    {
      messageType:=rsr,
      destLocRef:=pl_DLR,
      sourceLocRef:=pl_SLR
    }

//******************************************************************************
// Message Protocol data unit error (ERR) (Q713 $4.16)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template          PDU_SCCP_ProtDataUnitError t_PDU_SCCP_ProtDataUnitError
(
         SCCP_param_DestLocalReference        pl_DLR,
         SCCP_param_ErrorCause                pl_ErrCause
):=
  {
    messageType:=rsr,
    destLocRef:=pl_DLR,
    errorCause:=pl_ErrCause
  }


//******************************************************************************
// Message Inactivity test (IT) (Q713 $4.17)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template          PDU_SCCP_InactivityTest t_PDU_SCCP_InactivityTest
(
         SCCP_param_DestLocalReference        pl_DLR,
         SCCP_param_SourceLocalReference      pl_SLR,
         SCCP_param_ProtocolClass             pl_Proto_Class,
         SCCP_param_SequencingSegmenting      pl_SeqSegm,
         SCCP_param_Credit                    pl_credit
):=
  {
    messageType:=it,
    destLocRef:=pl_DLR,
    sourceLocRef:=pl_SLR,
    protClass:=pl_Proto_Class,
    sequencingSegmenting:=pl_SeqSegm,
    credit:=pl_credit
  }


//******************************************************************************
// Message Extended Unitdata (XUDT) (Q713 $4.18)
//******************************************************************************
//------------------------------------------------------------------------------

template          PDU_SCCP_ExtUnitdata t_PDU_SCCP_ExtUnitdata
(
            SCCP_param_ProtocolClass            pl_Proto_Class,
            SCCP_param_HopCounter               pl_hopCounter,
            SCCP_param_CPartyAddressEnc         pl_calledPAddress,
            SCCP_param_CPartyAddressEnc         pl_callingPAddress,
            SCCP_param_Data                     pl_data,
template    SCCP_param_Segmentation_opt         pl_segm,
template    SCCP_param_Importance_opt           pl_imp
):=
  {
    messageType:= xudt,
    protClass:=pl_Proto_Class,
    hopCounter:=pl_hopCounter,
    pointer1:=0,
    pointer2:=0,
    pointer3:=0,
    pointer4:=0,
    calledPAddress:=pl_calledPAddress,
    callingPAddress:=pl_callingPAddress,
    data := pl_data,
    optionalPart:= {
      segmentation:=pl_segm,
      importance := pl_imp
    },
    eop:= { paramName:=con_SCCP_eop }
  }


//******************************************************************************
// Message Extended Unitdata Service(XUDTS) (Q713 $4.19)
//******************************************************************************
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------



//******************************************************************************
// Message Long Unitdata (LUDT) (Q713 $4.20)
//******************************************************************************
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------


//******************************************************************************
// Message Long Unitdata Service (LUDTS) (Q713 $4.21)
//******************************************************************************

//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------


//******************************************************************************
// SCCP management messages (Q713 $5.3)
//******************************************************************************
//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------



}//endgroup PDUTemplateDefinitionsSending

//******************************************************************************

group PDUTemplateDefinitionsReceiving
{



//******************************************************************************
// Message Connection Request (CR) (Q713 $4.2)
//******************************************************************************

//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
  template           PDU_SCCP_ConnectionRequest tr_PDU_SCCP_ConnectionRequest:=
  {
    messageType:=cr,
    sourceLocRef:=?,
    protClass:=?,
    pointer1:=?,
    pointer2:=?,
    calledPAddress:=?,
    optionalPart:=    {
      credit:=*,
      callingPAddress:=*,
      data:=*,
      hopCounter:=*,
      importance:=*
    },
    eop:=*
  }



//******************************************************************************
// Message Connection Confirm (CC) (Q713 $4.3)
//******************************************************************************



//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template PDU_SCCP_ConnectionConfirm tr_PDU_SCCP_ConnectionConfirm:=
{
  messageType:=cc,
  destLocRef:=?,
  sourceLocRef:=?,
  protClass:=?,
  pointer1:=?,
  optionalPart:= {
    credit:=*,
    calledPAddress:=*,
    data:=*,
    importance:=*
  },
  eop:=*
}


//******************************************************************************
// Message Connection Refused (CREF) (Q713 $4.4)
//******************************************************************************

//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template  PDU_SCCP_ConnectionRefused tr_PDU_SCCP_ConnectionRefused:=
{
  messageType:=cref,
  destLocRef:=?,
  refusalCause:=?,
  pointer1:=?,
  optionalPart:=  {
    calledPAddress:=*,
    data:=*,
    importance:=*
  },
  eop:=*
}


//******************************************************************************
// Message Released (RLSD) (Q713 $4.5)
//******************************************************************************

//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template  PDU_SCCP_Released tr_PDU_SCCP_Released:=
{
  messageType:=rlsd,
  destLocRef:=?,
  sourceLocRef:=?,
  releaseCause:=?,
  pointer1:=?,
  optionalPart:=  {
    data:=*,
    importance:=*
    },
  eop:=*
}



//******************************************************************************
// Message Release Complete (RLC) (Q713 $4.6)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------

template          PDU_SCCP_ReleaseComplete  tr_PDU_SCCP_ReleaseComplete:=
{
  messageType:=rlc,
  destLocRef:=?,
  sourceLocRef:=?
}



//******************************************************************************
// Message Data form 1 (DT1) (Q713 $4.7)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------
template           PDU_SCCP_DataForm1  tr_PDU_SCCP_DataForm1:=
{
  messageType:=dt1,
  destLocRef:=?,
  segmentingReassembl:=?,
  pointer1:=?,
  data:=?
}

//******************************************************************************
// Message Data form 2 (DT2) (Q713 $4.8)
//******************************************************************************
//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------

//******************************************************************************
// Message Data Acknowledgement (AK) (Q713 $4.9)
//******************************************************************************
//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------


//******************************************************************************
// Message Unitdata (UDT) (Q713 $4.10)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------

template          PDU_SCCP_Unitdata tr_PDU_SCCP_Unitdata:=
{
  messageType:=udt,
  protClass:=?,
  pointer1:=?,
  pointer2:=?,
  pointer3:=?,
  calledPAddress:=?,
  callingPAddress:=?,
  data:=?
}

//******************************************************************************
// Message Unitdata service (UDTS) (Q713 $4.11)
//******************************************************************************
//------------------------------------------------------------------------------
// Message definition
//------------------------------------------------------------------------------

template          PDU_SCCP_UnitdataService  tr_PDU_SCCP_UnitdataService:=
{
  messageType:=udts,
  returnCause:=?,
  pointer1:=?,
  pointer2:=?,
  pointer3:=?,
  calledPAddress:=?,
  callingPAddress:=?,
  data:=?
}

//******************************************************************************
// Message Expedited Data (ED) (Q713 $4.12)
//******************************************************************************
//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------


//******************************************************************************
// Message Expedited Data Acknowledgement (EA) (Q713 $4.13)
//******************************************************************************
//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------

//******************************************************************************
// Message Reset Request (RSR) (Q713 $4.14)
//******************************************************************************

template          PDU_SCCP_ResetRequest tr_PDU_SCCP_ResetRequest:=
{
  messageType:=rsr,
  destLocRef:=?,
  sourceLocRef:=?,
  resetCause:=?
}

//******************************************************************************
// Message Reset Confirmation (RSC) (Q713 $4.15)
//******************************************************************************

template          PDU_SCCP_ResetConfirm  tr_PDU_SCCP_ResetConfirm:=
{
  messageType:=rsr,
  destLocRef:=?,
  sourceLocRef:=?
}

//******************************************************************************
// Message Protocol data unit error (ERR) (Q713 $4.16)
//******************************************************************************

template          PDU_SCCP_ProtDataUnitError tr_PDU_SCCP_ProtDataUnitError:=
{
  messageType:=rsr,
  destLocRef:=?,
  errorCause:=?
}

//******************************************************************************
// Message Inactivity test (IT) (Q713 $4.17)
//******************************************************************************

template          PDU_SCCP_InactivityTest tr_PDU_SCCP_InactivityTest:=
{
  messageType:=it,
  destLocRef:=?,
  sourceLocRef:=?,
  protClass:=?,
  sequencingSegmenting:=?,
  credit:=?
}

//******************************************************************************
// Message Extended Unitdata (XUDT) (Q713 $4.18)
//******************************************************************************


template          PDU_SCCP_ExtUnitdata tr_PDU_SCCP_ExtUnitdata :=
{
  messageType:=xudt,
  protClass:= ?, //connection oriented but no flow control
  hopCounter:=?,
  pointer1:=?,
  pointer2:=?,
  pointer3:=?,
  pointer4:=?,
  calledPAddress:=?,
  callingPAddress:=?,
  data := ?,
  optionalPart:= {
    segmentation:=*,
    importance := *
  },
  eop:= *
}

//------------------------------------------------------------------------------

//******************************************************************************
// Message Extended Unitdata Service(XUDTS) (Q713 $4.19)
//******************************************************************************
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------

//******************************************************************************
// Message Long Unitdata (LUDT) (Q713 $4.20)
//******************************************************************************
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------


//******************************************************************************
// Message Long Unitdata Service (LUDTS) (Q713 $4.21)
//******************************************************************************

//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------


//******************************************************************************
// SCCP management messages (Q713 $5.3)
//******************************************************************************
//------------------------------------------------------------------------------
// Not supported
//------------------------------------------------------------------------------



}//endgroup PDUTemplateDefinitionsReceiving

type record of boolean Timer_Snapshot;
type enumerated TimerIdentifierType {conn_est, ias, iar, rel, repeat_rel, int, reset,internal_reset, t_guard};


type component SCCP_CT
{ //startcomponent  SCCP_CT

  //Component variables
  //***************************************************************
  // Connection Oriented Signalling:
  // StateTransition-> ConnectionData;
  var ConnectionData ConnectionTable[16]; //16 connections 0 to 15
  var integer   v_session; // actual conn. oriented session index

  // Connectioenless Signalling:
  //== sending ==
  var OCT3  segmLocRefTable[16];
  var integer v_segmLocRefIndex; // last index in segmLocRefTable, cyclical incremented
  //==receiving==
  var ClessRcvBuff ClessRcvBuffTable[16];

  var integer    v_reference; // not used ???

  var hexstring v_own_GT;
  var hexstring v_remote_GT;
  var integer   v_SSN;
  var OCT1        v_SIO;
  var integer     v_NI; //network indicator, if NI<2 => international
  var integer     v_own_SPC;
  var integer     v_remote_SPC;
  var integer     v_SLS;

  var SCCP_ServiceType v_SCCPServiceType; //enum: itu, ansi, ttc or mpt
  //var v_maxLocalReference; // Local Reference max. value, see in SCCP.ttcn
  var integer     v_PC_length; //length of point code, calculated at start! NOT USED
  var integer     v_RoutingLabelLen; //in bytes
  var integer     v_sccp_data_maxlen; // dt1 payload length upper limit
  var integer     v_sccp_pdu_maxlen;  // SIF len -routing label len
  
  var Timer_Snapshot v_T_conn_est;
  var Timer_Snapshot v_T_ias;
  var Timer_Snapshot v_T_iar;
  var Timer_Snapshot v_T_rel;  
  var Timer_Snapshot v_T_repeat_rel;  
  var Timer_Snapshot v_T_int;  
  var Timer_Snapshot v_T_reset;    
  var Timer_Snapshot v_T_internal_reset;    
  var Timer_Snapshot v_T_guard;  
  //var Timer_Snapshot v_T_T_guard;    
  //***************************************************************

  port SCCPasp_SP_PT   SCCP_SP_PORT;//port type defined in SCCP_ASPs
  port MTP3asp_SCCP_PT MTP3_SCCP_PORT;

  //component timers

  timer T_conn_est[cg_TimerArraySize]:= { tspc_timer_T_conn_est,tspc_timer_T_conn_est,
    tspc_timer_T_conn_est,tspc_timer_T_conn_est,
    tspc_timer_T_conn_est,tspc_timer_T_conn_est,
    tspc_timer_T_conn_est,tspc_timer_T_conn_est,
    tspc_timer_T_conn_est,tspc_timer_T_conn_est,
    tspc_timer_T_conn_est,tspc_timer_T_conn_est,
    tspc_timer_T_conn_est,tspc_timer_T_conn_est,
    tspc_timer_T_conn_est,tspc_timer_T_conn_est };

  timer T_ias[cg_TimerArraySize]:=   { tspc_timer_T_ias,tspc_timer_T_ias,
    tspc_timer_T_ias,tspc_timer_T_ias,
    tspc_timer_T_ias,tspc_timer_T_ias,
    tspc_timer_T_ias,tspc_timer_T_ias,
    tspc_timer_T_ias,tspc_timer_T_ias,
    tspc_timer_T_ias,tspc_timer_T_ias,
    tspc_timer_T_ias,tspc_timer_T_ias,
    tspc_timer_T_ias,tspc_timer_T_ias };

  timer T_iar[cg_TimerArraySize]:= { tspc_timer_T_iar,tspc_timer_T_iar,
    tspc_timer_T_iar,tspc_timer_T_iar,
    tspc_timer_T_iar,tspc_timer_T_iar,
    tspc_timer_T_iar,tspc_timer_T_iar,
    tspc_timer_T_iar,tspc_timer_T_iar,
    tspc_timer_T_iar,tspc_timer_T_iar,
    tspc_timer_T_iar,tspc_timer_T_iar,
    tspc_timer_T_iar,tspc_timer_T_iar };

  timer T_rel[cg_TimerArraySize]:= { tspc_timer_T_rel,tspc_timer_T_rel,
    tspc_timer_T_rel,tspc_timer_T_rel,
    tspc_timer_T_rel,tspc_timer_T_rel,
    tspc_timer_T_rel,tspc_timer_T_rel,
    tspc_timer_T_rel,tspc_timer_T_rel,
    tspc_timer_T_rel,tspc_timer_T_rel,
    tspc_timer_T_rel,tspc_timer_T_rel,
    tspc_timer_T_rel,tspc_timer_T_rel };

  timer T_repeat_rel[cg_TimerArraySize]:= { tspc_timer_T_repeat_rel,tspc_timer_T_repeat_rel,
    tspc_timer_T_repeat_rel,tspc_timer_T_repeat_rel,
    tspc_timer_T_repeat_rel,tspc_timer_T_repeat_rel,
    tspc_timer_T_repeat_rel,tspc_timer_T_repeat_rel,
    tspc_timer_T_repeat_rel,tspc_timer_T_repeat_rel,
    tspc_timer_T_repeat_rel,tspc_timer_T_repeat_rel,
    tspc_timer_T_repeat_rel,tspc_timer_T_repeat_rel,
    tspc_timer_T_repeat_rel,tspc_timer_T_repeat_rel };

  timer T_int[cg_TimerArraySize]:= { tspc_timer_T_int,tspc_timer_T_int,
    tspc_timer_T_int,tspc_timer_T_int,
    tspc_timer_T_int,tspc_timer_T_int,
    tspc_timer_T_int,tspc_timer_T_int,
    tspc_timer_T_int,tspc_timer_T_int,
    tspc_timer_T_int,tspc_timer_T_int,
    tspc_timer_T_int,tspc_timer_T_int,
    tspc_timer_T_int,tspc_timer_T_int };


/*  timer T_T_guard[cg_TimerArraySize]:= { tspc_timer_T_guard,tspc_timer_T_guard,
    tspc_timer_T_guard,tspc_timer_T_guard,
    tspc_timer_T_guard,tspc_timer_T_guard,
    tspc_timer_T_guard,tspc_timer_T_guard,
    tspc_timer_T_guard,tspc_timer_T_guard,
    tspc_timer_T_guard,tspc_timer_T_guard,
    tspc_timer_T_guard,tspc_timer_T_guard,
    tspc_timer_T_guard,tspc_timer_T_guard };
*/    

  timer T_reset[cg_TimerArraySize]:= { tspc_timer_T_reset,tspc_timer_T_reset,
    tspc_timer_T_reset,tspc_timer_T_reset,
    tspc_timer_T_reset,tspc_timer_T_reset,
    tspc_timer_T_reset,tspc_timer_T_reset,
    tspc_timer_T_reset,tspc_timer_T_reset,
    tspc_timer_T_reset,tspc_timer_T_reset,
    tspc_timer_T_reset,tspc_timer_T_reset,
    tspc_timer_T_reset,tspc_timer_T_reset };


  timer T_internal_reset[cg_TimerArraySize]:= { tspc_timer_T_internal_reset,tspc_timer_T_internal_reset,
    tspc_timer_T_internal_reset,tspc_timer_T_internal_reset,
    tspc_timer_T_internal_reset,tspc_timer_T_internal_reset,
    tspc_timer_T_internal_reset,tspc_timer_T_internal_reset,
    tspc_timer_T_internal_reset,tspc_timer_T_internal_reset,
    tspc_timer_T_internal_reset,tspc_timer_T_internal_reset,
    tspc_timer_T_internal_reset,tspc_timer_T_internal_reset,
    tspc_timer_T_internal_reset,tspc_timer_T_internal_reset };


  timer T_guard[cg_TimerArraySize]:= { tspc_timer_guard,tspc_timer_guard,
    tspc_timer_guard,tspc_timer_guard,
    tspc_timer_guard,tspc_timer_guard,
    tspc_timer_guard,tspc_timer_guard,
    tspc_timer_guard,tspc_timer_guard,
    tspc_timer_guard,tspc_timer_guard,
    tspc_timer_guard,tspc_timer_guard,
    tspc_timer_guard,tspc_timer_guard };

}//endcomponent  SCCP_CT


group SCCPFunctions
{//startgroup SCCPFunctions
  //******************************************************************
  function f_StartTimer(TimerIdentifierType pl_TimerIdentifier,integer pl_TimerIndex,float pl_duration := -1.0) runs on SCCP_CT 
  //******************************************************************
  {
  select (pl_TimerIdentifier)
    {
      case(conn_est)
       {
         if(pl_duration < 0.0){
           T_conn_est[pl_TimerIndex].start;
           v_T_conn_est[pl_TimerIndex] := true;           
           }
         else{
           T_conn_est[pl_TimerIndex].start(pl_duration);   
           v_T_conn_est[pl_TimerIndex] := true;                         
         }            
       }
      case(ias)
       {
        if(pl_duration < 0.0){             
          T_ias[pl_TimerIndex].start;
          v_T_ias[pl_TimerIndex] := true;
          }
        else{   
          T_ias[pl_TimerIndex].start(pl_duration);
          v_T_ias[pl_TimerIndex] := true;          
         }         
       }          
      case(iar)
       {  
        if(pl_duration  < 0.0){                  
          T_iar[pl_TimerIndex].start;
          v_T_iar[pl_TimerIndex] := true; 
         }
        else{  
          T_iar[pl_TimerIndex].start(pl_duration);
          v_T_iar[pl_TimerIndex] := true;                    
         } 
       }               
      case(rel) 
       {  
        if(pl_duration  < 0.0){                         
          T_rel[pl_TimerIndex].start;
          v_T_rel[pl_TimerIndex] := true;  
          }
        else{  
          T_rel[pl_TimerIndex].start(pl_duration);
          v_T_rel[pl_TimerIndex] := true;                      
        }              
       }          
      case(repeat_rel)
       {  
        if(pl_duration  < 0.0){                
          T_repeat_rel[pl_TimerIndex].start;
          v_T_repeat_rel[pl_TimerIndex] := true;   
        }  
        else{            
          T_repeat_rel[pl_TimerIndex].start(pl_duration);
          v_T_repeat_rel[pl_TimerIndex] := true;                     
        }   
       }            
      case(int)  
       { 
        if(pl_duration  < 0.0){                
          T_int[pl_TimerIndex].start;
          v_T_int[pl_TimerIndex] := true;
        }
        else{    
          T_int[pl_TimerIndex].start(pl_duration);
          v_T_int[pl_TimerIndex] := true;        
         }    
        }            
      case(reset)
       { 
        if(pl_duration  < 0.0){                   
          T_reset[pl_TimerIndex].start;
          v_T_reset[pl_TimerIndex] := true; 
        }
        else{ 
          T_reset[pl_TimerIndex].start(pl_duration);
          v_T_reset[pl_TimerIndex] := true;         
        }                      
       }            
      case(internal_reset) 
       { 
        if(pl_duration  < 0.0){                    
          T_internal_reset[pl_TimerIndex].start;
          v_T_internal_reset[pl_TimerIndex] := true;  
        }
        else{ 
          T_internal_reset[pl_TimerIndex].start(pl_duration);
          v_T_internal_reset[pl_TimerIndex] := true;                 
        }
       }                 
      case(t_guard)
       {
        if(pl_duration  < 0.0){                     
          T_guard[pl_TimerIndex].start;
          v_T_guard[pl_TimerIndex] := true;  
        }  
        else{
          T_guard[pl_TimerIndex].start(pl_duration);
          v_T_guard[pl_TimerIndex] := true;                      
        }  
       }                       
      case else
     {log("Warning: Incorrect Timer!")}              
    }      
  }
  //******************************************************************
  function f_StopTimer(TimerIdentifierType pl_TimerIdentifier,integer pl_TimerIndex) runs on SCCP_CT
  //******************************************************************
  {
  select (pl_TimerIdentifier)
    {
      case(conn_est)
       {
          T_conn_est[pl_TimerIndex].stop;
          v_T_conn_est[pl_TimerIndex] := false;
       }
      case(ias)
       {      
          T_ias[pl_TimerIndex].stop;
          v_T_ias[pl_TimerIndex] := false;
       }          
      case(iar)
       {      
          T_iar[pl_TimerIndex].stop;
          v_T_iar[pl_TimerIndex] := false; 
       }               
      case(rel) 
       {        
          T_rel[pl_TimerIndex].stop;
          v_T_rel[pl_TimerIndex] := false;    
       }          
      case(repeat_rel)
       {      
          T_repeat_rel[pl_TimerIndex].stop;
          v_T_repeat_rel[pl_TimerIndex] := false;   
        }            
      case(int)  
       {       
          T_int[pl_TimerIndex].stop;
          v_T_int[pl_TimerIndex] := false;   
        }            
      case(reset)
       {      
          T_reset[pl_TimerIndex].stop;
          v_T_reset[pl_TimerIndex] := false;  
       }            
      case(internal_reset) 
       {       
          T_internal_reset[pl_TimerIndex].stop;
          v_T_internal_reset[pl_TimerIndex] := false;  
       }                 
      case(t_guard)
       {        
          T_guard[pl_TimerIndex].stop;
          v_T_guard[pl_TimerIndex] := false;  
       }                  
      case else
     {log("Warning: Incorrect Timer!")}              
    }      
  }
  
  //******************************************************************  
  function f_initialize_timer_states() runs on SCCP_CT
  //******************************************************************  
  {  
    var integer i;
    for (i:=0; i<cg_TimerArraySize;i:=i+1) {  
      v_T_conn_est[i] := false;
      v_T_ias[i] := false;
      v_T_iar[i] := false;
      v_T_rel[i] := false;
      v_T_repeat_rel[i] := false;
      v_T_int[i] := false;
      v_T_reset[i] := false;
      v_T_internal_reset[i] := false;
      v_T_guard[i] :=  false;      
    }
  }

  //******************************************************************
  function SCCPStart(MSC_SCCP_MTP3_parameters pl_Boot) runs on SCCP_CT
  //******************************************************************
  {
    //local declarations
    var integer vl_j;

    //initializes variables  with 'SCCP_CT' visibility/scope
    v_segmLocRefIndex := 0;
    v_reference:=0;
    v_SIO:= bit2oct(pl_Boot.sio.ni & pl_Boot.sio.prio & pl_Boot.sio.si);
    v_NI := oct2int(v_SIO)/64;
    v_own_SPC:=pl_Boot.opc;
    v_remote_SPC:=pl_Boot.dpc;
    v_SLS:=pl_Boot.sls;
    v_SCCPServiceType := pl_Boot.sccp_serviceType;

    if (ispresent(pl_Boot.ssn))
    {
      v_SSN:=pl_Boot.ssn;
    }
    else
    {
      v_SSN:=0;
    }
    if( (v_SCCPServiceType == mtp3_itu) or
        (v_SCCPServiceType == mtp3b_itu) )
    {
       v_RoutingLabelLen  := 4;
    }
    else if( (v_SCCPServiceType == mtp3_ansi) or
             (v_SCCPServiceType == mtp3b_ansi) )
    {
      v_RoutingLabelLen := 7;
    }
    else if (  (v_SCCPServiceType == mtp3_ttc) or
                (v_SCCPServiceType == mtp3b_ttc)  )
    {
      if(v_NI>= 2) { v_RoutingLabelLen := 5;  }
      else { v_RoutingLabelLen := 4;   }
    }
    else if( v_SCCPServiceType == m3ua )
    {
      v_RoutingLabelLen := 4; // not really...
      //v_sccp_data_maxlen := 261;
    }
    else if (  (v_SCCPServiceType == mtp3_mpt))
    {
      if(v_NI== 2) { v_RoutingLabelLen := 7;  }
      else { v_RoutingLabelLen := 4;   }
    }
    else
    {
      log( "Wrong SCCPServiceType value was selected in the config file");
      log("Modified for default value 'mtp3_itu'.");
      v_SCCPServiceType := mtp3_itu;
      v_RoutingLabelLen := 4; //itu

    }

    // mtp3_itu_b i.e. itu mtp3b
    // SCCP_ansi_b i.e ansi mtp3b settings ???
    //272= max length of SIF, see Fig3-3B/T1.111.4-2001
    //temp for test: 10 ?
    //tsp_SIF_MaxLength = 272
    v_sccp_pdu_maxlen  := tsp_SIF_MaxLength - v_RoutingLabelLen; // -; //7: msg_type+locref+ptr+len
    log("v_sccp_pdu_maxlen:",v_sccp_pdu_maxlen);
    v_sccp_data_maxlen := v_sccp_pdu_maxlen-7; // dt1 payload // -7: msg_type+locref+ptr+len

    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {
      ConnectionTable[vl_j].localReference :='000000'O;
      ConnectionTable[vl_j].remoteReference:='000000'O;
      ConnectionTable[vl_j].state          :=idle;
      ConnectionTable[vl_j].connectionId   :=0;
      ConnectionTable[vl_j].reassembler_buffer.buffer :=''O;
      ConnectionTable[vl_j].reassembler_buffer.actlen := 0;
      ConnectionTable[vl_j].reassembler_buffer.maxlen := 16*v_sccp_data_maxlen; //????
      segmLocRefTable[vl_j] := '000000'O;
      reallocate_ClessRcvBuff(vl_j);

    }//endfor

    //starts SCCP execution
    ScanEvents();
  }//endfunction of SCCPStart


  //******************************************************************
  function ReleaseResources(in integer pl_session) runs on SCCP_CT
  //******************************************************************
  {//startfunction

    //release resources
    ConnectionTable[pl_session].remoteReference:='000000'O;
    ConnectionTable[pl_session].localReference:='000000'O;
    ConnectionTable[pl_session].connectionId:=0;
    Stop_sessionTimers(pl_session);
    ConnectionTable[pl_session].state:=idle;
    ConnectionTable[pl_session].reassembler_buffer.buffer:=''O;
    ConnectionTable[pl_session].reassembler_buffer.actlen:=0;
  }//endfunction ReleaseResources

  //******************************************************************
  function GuardTimer_Expired(in integer pl_session) runs on SCCP_CT
  //no answer to ASP_SCCP_N_CONNECT_ind received
  //******************************************************************
  {//startfunction

    //local declarations
    var   PDU_SCCP                 vl_PDU_SCCP;

    //Action Table follows

    if (ConnectionTable[pl_session].state==connection_pending_IC)
    {//startif

      //send Released-this should disconnect the other end
      vl_PDU_SCCP.released.messageType:=rlsd;
      vl_PDU_SCCP.released.destLocRef:=ConnectionTable[pl_session].remoteReference;
      vl_PDU_SCCP.released.sourceLocRef:=ConnectionTable[pl_session].localReference;
      vl_PDU_SCCP.released.releaseCause:=cg_Rel_endUserOrig;
      vl_PDU_SCCP.released.pointer1:=0;
      vl_PDU_SCCP.released.optionalPart:=omit;
      vl_PDU_SCCP.released.eop:=omit;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Released

      //release resources, return to idle
      ReleaseResources(pl_session);

    }//endif

  }//endfunction GuardTimer_Expired


  //******************************************************************
  function InternalResetTimer_Expired(integer pl_session) runs on SCCP_CT
  //******************************************************************
  {//startfunction

    //local declarations
    var   PDU_SCCP  vl_PDU_SCCP;
    var   ASP_SCCP_N_RESET_ind       vl_N_RESET_ind;

    //Action Table follows

    if (ConnectionTable[pl_session].state==active)
    {//startif
      //send ASP_SCCP_N_RESET_ind
      //assemble ASP_SCCP_N_ASP
      vl_N_RESET_ind.originator:=cg_NSP;
      vl_N_RESET_ind.reason:=cg_DISC_abnormal_T;
      vl_N_RESET_ind.connectionId:=ConnectionTable[pl_session].connectionId;

      SCCP_SP_PORT.send( t_ASP_N_RESET_ind(
        vl_N_RESET_ind.originator,
        vl_N_RESET_ind.reason,
        vl_N_RESET_ind.connectionId
        ));//send ASP_SCCP_N_RESET_ind
        //send Reset Request

      vl_PDU_SCCP.resetreq.messageType:=rsr;
      vl_PDU_SCCP.resetreq.destLocRef:=ConnectionTable[pl_session].remoteReference;
      vl_PDU_SCCP.resetreq.sourceLocRef:=ConnectionTable[pl_session].localReference;
      vl_PDU_SCCP.resetreq.resetCause:=cg_Res_endUserOrig;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Reset Request

      //start reset timer

      f_StartTimer(reset,pl_session);
      //restart send inactivity timer
      f_StopTimer(ias,pl_session);//to avoid warnings
      f_StartTimer(ias,pl_session);
      //reset variables etc.
      //change state
      ConnectionTable[pl_session].state:=reset_bothway;

    }//endif
  }//InternalResetTimer_Expired

  //******************************************************************
  function Reset_Timer_Expired(integer pl_session) runs on SCCP_CT
  //******************************************************************
  {//startfunction

    //local declarations
    var   ASP_SCCP_N_DISCONNECT_ind vl_N_DISCONNECT_ind;

    //Action Table follows
    if (ConnectionTable[pl_session].state==reset_bothway)
    {//startif

      //assemble ASP_SCCP_N_
      vl_N_DISCONNECT_ind.originator:=cg_NSP;
      vl_N_DISCONNECT_ind.reason:=cg_DISC_abnormal_T;
      vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[pl_session].connectionId;

      SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
        vl_N_DISCONNECT_ind.originator,
        omit,
        vl_N_DISCONNECT_ind.reason,
        omit,
        vl_N_DISCONNECT_ind.connectionId,
        omit
      ));//send ASP_SCCP_N_DISCONNECT_ind

      //release resources, stop inactivity timers, change state to idle
      ReleaseResources(pl_session);
    }//endif

  }//Reset_Timer_Expired

  //******************************************************************
  function Interval_Timer_Expired(integer pl_session) runs on SCCP_CT
  //******************************************************************
  {//startfunction

    //Action Table follows
    if (ConnectionTable[pl_session].state==disconnect_pending)
    {
      log ("Interval timer expired");
      //release resources
      ReleaseResources(pl_session);
    }

  }//Interval_Timer_Expired



  //******************************************************************
  function RepeatRelease_Timer_Expired(integer pl_session) runs on SCCP_CT
  //******************************************************************
  {

    //local declarations
    var   PDU_SCCP  vl_PDU_SCCP;

    //Action Table follows
    if (ConnectionTable[pl_session].state==disconnect_pending)
    {
      //assemble and route MTP3_ASP
      vl_PDU_SCCP.released.messageType:=rlsd;
      vl_PDU_SCCP.released.destLocRef:=ConnectionTable[pl_session].remoteReference;
      vl_PDU_SCCP.released.sourceLocRef:=ConnectionTable[pl_session].localReference;
      vl_PDU_SCCP.released.releaseCause:=cg_Res_endUserOrig;
      vl_PDU_SCCP.released.pointer1:=0;
      vl_PDU_SCCP.released.optionalPart:=omit;
      vl_PDU_SCCP.released.eop:=omit;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Released

      //restart repeat release timer
      f_StopTimer(repeat_rel,pl_session);//to avoid warnings
      f_StartTimer(repeat_rel,pl_session);
      //no state change, return
    }

  }//RepeatRelease_Timer_Expired


  //******************************************************************
  function Release_Timer_Expired(integer pl_session) runs on SCCP_CT
  //******************************************************************
  {

    //local declarations
    var   PDU_SCCP  vl_PDU_SCCP;

    //Action Table follows
    if (ConnectionTable[pl_session].state==disconnect_pending)
    {
      //assemble and route MTP3_ASP
      vl_PDU_SCCP.released.messageType:=rlsd;
      vl_PDU_SCCP.released.destLocRef:=ConnectionTable[pl_session].remoteReference;
      vl_PDU_SCCP.released.sourceLocRef:=ConnectionTable[pl_session].localReference;
      vl_PDU_SCCP.released.releaseCause:=cg_Res_endUserOrig;//?
      vl_PDU_SCCP.released.pointer1:=0;
      vl_PDU_SCCP.released.optionalPart:=omit;
      vl_PDU_SCCP.released.eop:=omit;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Released

      f_StartTimer(repeat_rel,pl_session);
      f_StartTimer(int,pl_session);
      //no state change, return

    }//endif

  }//Release_Timer_Expired


  //******************************************************************
  function ReceiveInactivity_Timer_Expired(integer pl_session) runs on SCCP_CT
  //******************************************************************
  {
    //local declarations
    var   PDU_SCCP                   vl_PDU_SCCP;
    var   ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;

    //Action Table follows
    if (ConnectionTable[pl_session].state==idle){}
    else if (ConnectionTable[pl_session].state==active)
    {
      //assemble ASP_SCCP_N_
      vl_N_DISCONNECT_ind.originator:=cg_NSP;
      vl_N_DISCONNECT_ind.reason:=cg_DISC_endUserFailure;//?
      vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[pl_session].connectionId;

      SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
         vl_N_DISCONNECT_ind.originator,
         omit,
         vl_N_DISCONNECT_ind.reason,
         omit,
         vl_N_DISCONNECT_ind.connectionId,
         omit
      ));//send ASP_SCCP_N_DISCONNECT_ind

      //stop inactivity timers
      f_StopTimer(ias,pl_session);
      f_StopTimer(iar,pl_session);

      //assemble and route MTP3_ASP

      vl_PDU_SCCP.released.messageType:=rlsd;
      vl_PDU_SCCP.released.destLocRef:=ConnectionTable[pl_session].remoteReference;
      vl_PDU_SCCP.released.sourceLocRef:=ConnectionTable[pl_session].localReference;
      vl_PDU_SCCP.released.releaseCause:=cg_Rel_expRecInacTimer;
      vl_PDU_SCCP.released.pointer1:=0;// No options
      vl_PDU_SCCP.released.optionalPart:=omit;
      vl_PDU_SCCP.released.eop:=omit;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Released

      //start release timer
      f_StartTimer(rel,pl_session);
      ConnectionTable[pl_session].state:=disconnect_pending;

    }//endif

  }//ReceiveInactivity_Timer_Expired


  //******************************************************************
  function SendInactivity_Timer_Expired(integer pl_session) runs on SCCP_CT
  //******************************************************************
  {

    //local declarations
    var   PDU_SCCP             vl_PDU_SCCP;

    //Action Table follows

    if (ConnectionTable[pl_session].state==active)
    {

      //assemble and route MTP3_ASP
      vl_PDU_SCCP.inacttest.messageType :=it;
      vl_PDU_SCCP.inacttest.destLocRef  :=ConnectionTable[pl_session].remoteReference;
      vl_PDU_SCCP.inacttest.sourceLocRef:=ConnectionTable[pl_session].localReference;

      vl_PDU_SCCP.inacttest.protClass:={
        class:='0010'B,
        messageHandling:='0000'B
      };//protocol class 2

      vl_PDU_SCCP.inacttest.sequencingSegmenting:={
        reserved:='0'B,
        p_s:='0000000'B,
        more:='0'B,
        pr:='0000000'B
      };//it will be ignored

      vl_PDU_SCCP.inacttest.credit:='00'O;
      //Param name credit(9), length 1, credit 0 -it will be mercifully ignored anyhow

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send inactivity test

      //restart send inactivity timer
      f_StopTimer(ias,pl_session);//to avoid warnings
      f_StartTimer(ias,pl_session);

    }//endif

  }//endfunction

  //******************************************************************
  function Conn_Timer_Expired(integer pl_session) runs on SCCP_CT
  //******************************************************************
  {

    //local declarations
    var        ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;

    if (ConnectionTable[pl_session].state==connection_pending_OG)
    {
      //assemble ASP_SCCP_N_
      vl_N_DISCONNECT_ind.originator:=cg_NSP;
      vl_N_DISCONNECT_ind.reason:=cg_DISC_abnormal_T;
      vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[pl_session].connectionId;

      SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
          vl_N_DISCONNECT_ind.originator,
          omit,
          vl_N_DISCONNECT_ind.reason,
          omit,
          vl_N_DISCONNECT_ind.connectionId,
          omit
          ));//send ASP_SCCP_N_DISCONNECT_ind

          //release resources
      ReleaseResources(pl_session);
    }
    else if (ConnectionTable[pl_session].state==wait_conn_confirm)
    {
      ReleaseResources(pl_session);
    }

  }//Conn_Timer_Expired

  //******************************************************************
  function GenerateLocalReference()  runs on SCCP_CT return OCT3
  //******************************************************************
  {
    var OCT3 vl_LocalReference;

    do
    {
      vl_LocalReference := int2oct(float2int(rnd()*tsp_maxLocalReference), 3 );
    }
    while ( Retrieve_session( vl_LocalReference ) != -1 );
    return vl_LocalReference;

  }//GenerateLocalReference

  //******************************************************************
  function GenerateConnectionId()  runs on SCCP_CT return integer
  //******************************************************************
  {
    var integer vl_ConnectionId;

    do { vl_ConnectionId := float2int(rnd()*tsp_max_ConnectionId); }
    while ( Retrieve_session_connectionId(  vl_ConnectionId ) != -1 );

    return vl_ConnectionId;
  }//GenerateConnectionId

  //******************************************************************
  function Stop_sessionTimers ( integer pl_session) runs on SCCP_CT
  //******************************************************************
  {
    if (T_conn_est[pl_session].running)
      { f_StopTimer(conn_est,pl_session);}
    if (T_ias[pl_session].running)
      { f_StopTimer(ias,pl_session);}
    if (T_iar[pl_session].running)
      { f_StopTimer(iar,pl_session);}
    if (T_rel[pl_session].running)
      { f_StopTimer(rel,pl_session);}
    if (T_repeat_rel[pl_session].running)
      { f_StopTimer(repeat_rel,pl_session);}
    if (T_int[pl_session].running)
      { f_StopTimer(int,pl_session);}
   // if (T_T_guard[pl_session].running)
   //   { f_StopTimer(t_t_guard,pl_session);}
    if (T_reset[pl_session].running)
      { f_StopTimer(reset,pl_session);}
    //T_reassembly[pl_session].stop;

  }//Stop_sessionTimers

  //******************************************************************
  function CheckIdleIndividuals()  runs on SCCP_CT return integer
  //******************************************************************
  {
    var integer vl_j;
    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {
       if (ConnectionTable[vl_j].state==idle)
       {
         log("First idle individual index:",vl_j);
         return vl_j;
       }
    }

    return -1;

  }//CheckIdleIndividuals

  //******************************************************************
  function ConnectionAlreadyEstablished(  OCT3 pl_LocRef) runs on SCCP_CT  return boolean
  //******************************************************************
  {
    var integer vl_j;
    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {
      if (ConnectionTable[vl_j].localReference==pl_LocRef)
      {
        return true;
      }
    }
    return false;

  } //ConnectionAlreadyEstablished

  //******************************************************************
  function ConnectionAlreadyEstablished_remote(  OCT3 pl_LocRef)  runs on SCCP_CT return boolean
  //******************************************************************
  {
    var integer vl_j;

    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {
      if (ConnectionTable[vl_j].remoteReference==pl_LocRef)
      {
        return true;
      }
    }
    return false;

  } //ConnectionAlreadyEstablished_remote

  //******************************************************************
  function ConnectionAlreadyEstablished_connectionId(integer pl_ConnId) runs on SCCP_CT  return boolean
  //******************************************************************
  {
    var integer vl_j;
    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {
      if (ConnectionTable[vl_j].connectionId==pl_ConnId)
      {
        return true;
      }
    }

    return false;

  } //ConnectionAlreadyEstablished_connectionId

  //******************************************************************
  function Retrieve_session(  OCT3 pl_LocRef ) runs on SCCP_CT  return integer
  //******************************************************************
  {
    var integer vl_j;
    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {

      if (ConnectionTable[vl_j].localReference==pl_LocRef)
      {
        log("Session index based on local reference:",vl_j);
        return vl_j;
      }
    }

    return -1;

  } //Retrieve_session

  //******************************************************************
  function Retrieve_session_remote(  OCT3 pl_LocRef )
  runs on SCCP_CT return integer
  //******************************************************************
  {
    var integer vl_j;
    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {
      if (ConnectionTable[vl_j].remoteReference==pl_LocRef)
      {
        log("Session index based on remote reference:",vl_j);
        return vl_j;
      }
    }
    return -1;

  } //Retrieve_session_remote

  //******************************************************************
  function Retrieve_session_connectionId(  integer pl_ConnId )
  runs on SCCP_CT return integer
  //******************************************************************
  {
    var integer vl_j;
    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {
      if (ConnectionTable[vl_j].connectionId==pl_ConnId)
      {
        log("Session index based on connection ID:",vl_j);
        return vl_j;
      }
    }
    return -1;

  } //Retrieve_session_connectionId

  //==================================================================
  // Connectionless Segmented Data Handling/
  //==================================================================
  //==================================================================
  // SENDING: SCCP->MTP3 Segmentation Local Reference Handling
  // Handles segmLocRefTable,v_segmLocRefIndex,
  // which are defined in SCCP_typedefs.ttcn
  //==================================================================

  //******************************************************************
  //function exist_segmLocalRef
  //******************************************************************

  function exist_segmLocalRef( in OCT3 pl_segLocRef)
  runs on SCCP_CT return boolean
  {
    if( get_segmLocalRefIndex(pl_segLocRef) == -1 ) { return false;}
    else { return true; };
  } //exist_segmLocalRef

  //******************************************************************
  //function get_segLocalRefIndex
  //******************************************************************

  function get_segmLocalRefIndex(in OCT3 pl_segmLocRef)
  runs on SCCP_CT return integer
  {
    var integer vl_j;
    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {
      if( segmLocRefTable[vl_j] == pl_segmLocRef ) { return vl_j;}
    }
    return -1;
  }//get_segLocalRefIndex

  //******************************************************************
  //function reset_segmLocalRef
  //******************************************************************
  function reset_segmLocalRef(in OCT3 pl_segmLocRef)
  runs on SCCP_CT
  {
    var integer vl_j;
    vl_j:= get_segmLocalRefIndex( pl_segmLocRef )
    segmLocRefTable[vl_j] := '000000'O;
  }

  //******************************************************************
  // function create_segmLocalRef
  //******************************************************************

  function create_segmLocalRef()
  runs on SCCP_CT return OCT3
  {
    var OCT3 vl_segmLocRef;
    v_segmLocRefIndex := (v_segmLocRefIndex +1) mod 16;
    do
    {
      vl_segmLocRef := int2oct(float2int( rnd() *tsp_maxLocalReference), 3 );
    }
    while ( exist_segmLocalRef( vl_segmLocRef ) );

    return vl_segmLocRef;
  }//create_segmLocalRef

  //==================================================================
  // RECEIVING CONNECTIONLESS PDUs BY SCCP
  //==================================================================

  //******************************************************************
  //function exist_ClessRcvBuff
  //******************************************************************
  function exist_ClessRcvBuff( in OCT3 pl_segmRemRef)
  runs on SCCP_CT return boolean
  {
    if( get_ClessRcvBuffIndex(pl_segmRemRef) == -1 ) { return false;}
    else { return true; };
  } //exist_ClessRcvBuff

  //******************************************************************
  //function get_segRemoteRefIndex
  //******************************************************************
  function get_ClessRcvBuffIndex(in OCT3 pl_segmRemRef)
  runs on SCCP_CT return integer
  {
    var integer vl_j;
    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {
      if( ClessRcvBuffTable[vl_j].segmRemoteRef == pl_segmRemRef )
      { return vl_j;}
    }
    return -1;
  }//get_ClessRcvBuffIndex

  //******************************************************************
  //function get_idle_ClessRcvBuffIndex
  //******************************************************************
  function get_idle_ClessRcvBuffIndex( )
  runs on SCCP_CT return integer
  {
    var integer vl_j;
    for (vl_j:=0;vl_j<16;vl_j:=vl_j+1)
    {
      if( ClessRcvBuffTable[vl_j].state == segmLocRef_idle ) { return vl_j;}
    }
    return -1;
  }//get_idle_ClessRcvBuffIndex

  //******************************************************************
  //function allocate_ClessRcvBuff
  //******************************************************************
  function allocate_ClessRcvBuff(in OCT3 pl_segmRemRef)
  runs on SCCP_CT return integer
  {
    var OCT3 vl_segmRemRef;
    var integer vl_j;

    if( exist_ClessRcvBuff(pl_segmRemRef) ){ return -1;};

    vl_j := get_idle_ClessRcvBuffIndex();
    ClessRcvBuffTable[vl_j].state := segmLocRef_busy;
    ClessRcvBuffTable[vl_j].segmRemoteRef := pl_segmRemRef;
    ClessRcvBuffTable[vl_j].reassembler_buffer.buffer:=''O;
    ClessRcvBuffTable[vl_j].reassembler_buffer.actlen:=0;
    return vl_j;

  }//allocate_ClessRcvBuff
  //******************************************************************
  //function reallocate_ClessRcvBuff
  //******************************************************************
  function reallocate_ClessRcvBuff(in  integer pl_index )
  runs on SCCP_CT
  {
    ClessRcvBuffTable[pl_index].state := segmLocRef_idle;
    // maybe unnecessaryy
    ClessRcvBuffTable[pl_index].segmRemoteRef := '000000'O;
    ClessRcvBuffTable[pl_index].reassembler_buffer.buffer:=''O;
    ClessRcvBuffTable[pl_index].reassembler_buffer.actlen:=0;
    return;
  }

  //******************************************************************
  //function store_segmData
  //******************************************************************
  function store_segmData(in  integer pl_index, in PDU_SCCP_ExtUnitdata pl_PDU_SCCP_ExtUnitdata)
  runs on SCCP_CT
  {
    ClessRcvBuffTable[pl_index].reassembler_buffer.buffer:=
      ClessRcvBuffTable[pl_index].reassembler_buffer.buffer&
      pl_PDU_SCCP_ExtUnitdata.data.data;
    ClessRcvBuffTable[pl_index].reassembler_buffer.actlen:=
      ClessRcvBuffTable[pl_index].reassembler_buffer.actlen+
      pl_PDU_SCCP_ExtUnitdata.data.paramLength;
  } //store_segmData

  //******************************************************************
  //function send_ClessRcvBuff_in_N_UNITDATAind
  //******************************************************************
  function send_ClessRcvBuff_in_N_UNITDATAind (
    in integer pl_index,
    in PDU_SCCP_ExtUnitdata pl_PDU_SCCP_ExtUnitdata)
  runs on SCCP_CT
  {
      var ASP_SCCP_N_UNITDATA_ind vl_N_UNITDATA_ind;

      vl_N_UNITDATA_ind.calledAddress  :=
        ConvertPDUEncodedAddressToASPAddress( pl_PDU_SCCP_ExtUnitdata.calledPAddress );

      vl_N_UNITDATA_ind.callingAddress :=
        ConvertPDUEncodedAddressToASPAddress( pl_PDU_SCCP_ExtUnitdata.callingPAddress );

      vl_N_UNITDATA_ind.sequenceControl:=
        '0000000'B&pl_PDU_SCCP_ExtUnitdata.protClass.class[3];
      if( pl_PDU_SCCP_ExtUnitdata.protClass.messageHandling == '1000'B )
      { vl_N_UNITDATA_ind.returnOption   := '00000001'B; }
      else
      { vl_N_UNITDATA_ind.returnOption   := '00000000'B; }

      vl_N_UNITDATA_ind.userData := ClessRcvBuffTable[pl_index].reassembler_buffer.buffer;

      vl_N_UNITDATA_ind.importance := omit;

      SCCP_SP_PORT.send( vl_N_UNITDATA_ind );

      return;
  }//send_ClessRcvBuff_in_N_UNITDATAind

  //******************************************************************
  //function send_ClessData_in_N_UNITDATAind
  // unbuffered data sending
  //******************************************************************

  function send_ClessData_in_N_UNITDATAind (
    in PDU_SCCP_ExtUnitdata pl_PDU_SCCP_ExtUnitdata)
  runs on SCCP_CT
  {
      var ASP_SCCP_N_UNITDATA_ind vl_N_UNITDATA_ind;

      vl_N_UNITDATA_ind.calledAddress  :=
        ConvertPDUEncodedAddressToASPAddress( pl_PDU_SCCP_ExtUnitdata.calledPAddress );

      vl_N_UNITDATA_ind.callingAddress :=
        ConvertPDUEncodedAddressToASPAddress( pl_PDU_SCCP_ExtUnitdata.callingPAddress );

      vl_N_UNITDATA_ind.sequenceControl:=
        '0000000'B&pl_PDU_SCCP_ExtUnitdata.protClass.class[3];
      if( pl_PDU_SCCP_ExtUnitdata.protClass.messageHandling == '1000'B )
      { vl_N_UNITDATA_ind.returnOption   := '00000001'B; }
      else
      { vl_N_UNITDATA_ind.returnOption   := '00000000'B; }

      vl_N_UNITDATA_ind.userData := pl_PDU_SCCP_ExtUnitdata.data.data;

      vl_N_UNITDATA_ind.importance := omit;

      SCCP_SP_PORT.send( vl_N_UNITDATA_ind );
      return;
  }//send_ClessData_in_N_UNITDATAind

  //******************************************************************
  //  CONN.ORIENTED SEGMENTING/REASSEMBLING
  //******************************************************************

  //******************************************************************
  // SEGMENTING
  //******************************************************************

  //******************************************************************
  // function sending_dataform1s_in_ASP_MTP_TRANSFERreqs
  // segmentates data and sends segments in dataform1 messages
  // included in asp_MTP3_TRANSFERreq PDUs
  // == segmentation - connection oriented case ==
  // counterpair: buffered_sending_ASP_N_DATA_ind
  //******************************************************************
  function sending_dataform1s_in_ASP_MTP_TRANSFERreqs( in ASP_SCCP_N_DATA_req pl_N_DATA_req )
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;
    var integer vl_len;
    var integer vl_actdatalen;
    var SCCP_PAR_UserData vl_data;
    var integer vl_from; // first position in vl_data to be sent
    vl_data := pl_N_DATA_req.userData;
    vl_from := 0;
    // fixed part of messages:
    vl_PDU_SCCP.dataform1.messageType:=dt1;
    vl_PDU_SCCP.dataform1.destLocRef:=ConnectionTable[v_session].remoteReference;
    vl_PDU_SCCP.dataform1.segmentingReassembl:={
      more:='1'B,
      reserved:='0000000'B
    };
    vl_PDU_SCCP.dataform1.pointer1:=1;
    // variable part of messages:
    vl_len := lengthof(vl_data);

    while ( vl_len > 0 )
    {

      log("vl_len:",vl_len);
      log("vl_from",vl_from);
      if(vl_len > v_sccp_data_maxlen)
      {
        vl_actdatalen := v_sccp_data_maxlen;
        vl_PDU_SCCP.dataform1.segmentingReassembl.more :='1'B;
      }
      else
      {
        vl_actdatalen := vl_len;
        vl_PDU_SCCP.dataform1.segmentingReassembl.more :='0'B;
      };

      vl_PDU_SCCP.dataform1.data.data:= substr( vl_data, vl_from, vl_actdatalen);
      vl_PDU_SCCP.dataform1.data.paramLength:= vl_actdatalen;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Data Form1

      log( "data sent by MTP3_SCCP_PORT: ",vl_PDU_SCCP.dataform1.data.data);

      //restart send inactivity timer
      f_StopTimer(ias,v_session);//to avoid warnings
      f_StartTimer(ias,v_session);

      vl_from := vl_from + vl_actdatalen;
      vl_len  := vl_len  - vl_actdatalen;

    }//while
  } //sending_dataform1s_in_ASP_MTP_TRANSFERreqs

  //******************************************************************
  // REASSEMBLING
  //******************************************************************

  //******************************************************************
  // function buffered_sending_ASP_N_DATA_ind
  // counterpair of sending_dataform1s_in_ASP_MTP_TRANSFERreqs
  //******************************************************************

  function buffered_sending_ASP_N_DATA_ind( in PDU_SCCP_DataForm1 pl_PDU_SCCP_DataForm1 )
  runs on SCCP_CT
  {
    // Investigate this shorcut (not implemented):
    // if actlen==0 and more==0=> send immediately

    // DT1 should be put to the reassembly buffer
    var integer vl_newbufflen;
    log("DT1 will be put to the reassembly buffer");
    //log( ConnectionTable[v_session].connectionId );
    vl_newbufflen := ConnectionTable[v_session].reassembler_buffer.actlen +
      pl_PDU_SCCP_DataForm1.data.paramLength;

    if( vl_newbufflen <=  ConnectionTable[v_session].reassembler_buffer.maxlen)
    {
      ConnectionTable[v_session].reassembler_buffer.buffer :=
        ConnectionTable[v_session].reassembler_buffer.buffer &
        pl_PDU_SCCP_DataForm1.data.data;
      ConnectionTable[v_session].reassembler_buffer.actlen := vl_newbufflen;
      log("DT1 data has been put to the reassembly buffer");
    }
    else
    {
      //send as much as possible OR error ???? NOT READY YET !!!!
      //CONT HERE, ask LAFA
      log("Unexpected/unimplemented program branch");
    }

    // sending:
    if( pl_PDU_SCCP_DataForm1.segmentingReassembl.more == '0'B )
    {
      log("DT1/segmentingReassembl/more==0 received=> send ASP_SCCP_N_DATA comes");
      //send:
      SCCP_SP_PORT.send( t_ASP_N_DATA_ind(
        ConnectionTable[v_session].reassembler_buffer.buffer,
        ConnectionTable[v_session].connectionId,
        omit));

      //restart send inactivity timer
      f_StopTimer(ias,v_session);//to avoid warnings
      f_StartTimer(ias,v_session);

      // clear the buffer:
      ConnectionTable[v_session].reassembler_buffer.buffer :=''O;
      ConnectionTable[v_session].reassembler_buffer.actlen := 0;
    }
    else
    {
      log("DT1/segmentingReassembl/more==1 received=> sent to buffer only");
    }
  }//buffered_sending_ASP_N_DATA_ind


  //******************************************************************
  //    CONVERSIONS
  //******************************************************************
  //
  // Differences between standards are hidden here !!!!
  //
  // 3 different functions working on different structures with the
  // virtually indentical code

  //******************************************************************
  // Functions coding ASP address into octetstream
  //******************************************************************

  // ITU

  function ConvertASPAddressToEncodedAddress_itu( in SCCP_PAR_Address pl_ASPAddress)
    runs on SCCP_CT
    return SCCP_param_CPartyAddressEnc
  {

    var SCCP_param_CPartyAddress_itu vl_PDUAddress; //structured fit to encoding
    var SCCP_param_CPartyAddressEnc vl_PDUAddressEncoded;

    vl_PDUAddress.addressIndicator.pointCodeIndic:=
      pl_ASPAddress.addressIndicator.pointCodeIndic;

    vl_PDUAddress.addressIndicator.ssnIndicator:=
      pl_ASPAddress.addressIndicator.ssnIndicator;

    vl_PDUAddress.addressIndicator.globalTitleIndic:=
     pl_ASPAddress.addressIndicator.globalTitleIndic;

    vl_PDUAddress.addressIndicator.routingIndicator:=
      pl_ASPAddress.addressIndicator.routingIndicator;

    vl_PDUAddress.addressIndicator.reserved:='0'B;
    // if (ischosen(pl_ASPAddress.signPointCode) ) not used because it is mandatory field (???)

    //----signPointCode handling
    if ( ispresent( pl_ASPAddress.signPointCode )) {
      vl_PDUAddress.signPointCode :=
        '00'B&pl_ASPAddress.signPointCode;
    } else {
      vl_PDUAddress.signPointCode := omit;
    };

    //----subsystemNumber handling
    if ( ispresent( pl_ASPAddress.subsystemNumber ) ){
      vl_PDUAddress.subsystemNumber := pl_ASPAddress.subsystemNumber;
    } else {
      vl_PDUAddress.subsystemNumber :=omit;
    };

    // --- globalTitle handling--
    if ( ispresent(pl_ASPAddress.globalTitle))
    {//startif1

      var SCCP_ASPfield_GlobalTitle tmpGT ;
      tmpGT := pl_ASPAddress.globalTitle;

      if (ischosen(tmpGT.gti0001))
      {
        vl_PDUAddress.globalTitle.gti0001.natureOfAddress:=tmpGT.gti0001.natureOfAddress;
        vl_PDUAddress.globalTitle.gti0001.oddeven:=tmpGT.gti0001.oddeven;
        vl_PDUAddress.globalTitle.gti0001.globalTitleAddress:=tmpGT.gti0001.globalTitleAddress;
      }
      else if (ischosen(tmpGT.gti0010))
      {
        vl_PDUAddress.globalTitle.gti0010.translationType:=tmpGT.gti0010.translationType;
        vl_PDUAddress.globalTitle.gti0010.globalTitleAddress:=tmpGT.gti0010.globalTitleAddress;
      }
      else if (ischosen(tmpGT.gti0011))
      {
        vl_PDUAddress.globalTitle.gti0011.translationType:=tmpGT.gti0011.translationType;
        vl_PDUAddress.globalTitle.gti0011.encodingScheme:=tmpGT.gti0011.encodingScheme;
        vl_PDUAddress.globalTitle.gti0011.numberingPlan:=tmpGT.gti0011.numberingPlan;
        vl_PDUAddress.globalTitle.gti0011.globalTitleAddress:=tmpGT.gti0011.globalTitleAddress;
      }
      else if (ischosen(tmpGT.gti0100))
      {
        vl_PDUAddress.globalTitle.gti0100.translationType:=tmpGT.gti0100.translationType;
        vl_PDUAddress.globalTitle.gti0100.encodingScheme:=tmpGT.gti0100.encodingScheme;
        vl_PDUAddress.globalTitle.gti0100.numberingPlan:=tmpGT.gti0100.numberingPlan;
        vl_PDUAddress.globalTitle.gti0100.natureOfAddress:=tmpGT.gti0100.natureOfAddress;
        vl_PDUAddress.globalTitle.gti0100.reserved:='0'B;
        vl_PDUAddress.globalTitle.gti0100.globalTitleAddress:=tmpGT.gti0100.globalTitleAddress;
      }
    }
    else
    {
        vl_PDUAddress.globalTitle := omit;
    };

    vl_PDUAddressEncoded.addr:= enc_PDU_SCCP_Address_itu( vl_PDUAddress);
    vl_PDUAddressEncoded.paramLength:= lengthof(vl_PDUAddressEncoded.addr);

    return vl_PDUAddressEncoded;

  } //ConvertASPAddressToEncodedAddress_itu

  //******************************************************************

  // ANSI
  function ConvertASPAddressToEncodedAddress_ansi(in SCCP_PAR_Address pl_ASPAddress)
    runs on SCCP_CT return SCCP_param_CPartyAddressEnc
    {

    var SCCP_param_CPartyAddress_ansi  vl_PDUAddress; //structured fit to encoding
    var SCCP_param_CPartyAddressEnc vl_PDUAddressEncoded;

    vl_PDUAddress.addressIndicator.pointCodeIndic:=
      pl_ASPAddress.addressIndicator.pointCodeIndic;

    vl_PDUAddress.addressIndicator.ssnIndicator:=
      pl_ASPAddress.addressIndicator.ssnIndicator;

    vl_PDUAddress.addressIndicator.globalTitleIndic:=
     pl_ASPAddress.addressIndicator.globalTitleIndic;

    vl_PDUAddress.addressIndicator.routingIndicator:=
      pl_ASPAddress.addressIndicator.routingIndicator;

    vl_PDUAddress.addressIndicator.reserved:='1'B;

    //----signPointCode handling
    if ( ispresent( pl_ASPAddress.signPointCode )){
      vl_PDUAddress.signPointCode := pl_ASPAddress.signPointCode;
    } else {
      vl_PDUAddress.signPointCode := omit;
    };

    //----subsystemNumber handling
    if ( ispresent( pl_ASPAddress.subsystemNumber )) {
      vl_PDUAddress.subsystemNumber:=pl_ASPAddress.subsystemNumber;
    } else {
      vl_PDUAddress.subsystemNumber :=omit;
    };

    if (ispresent(pl_ASPAddress.globalTitle))
    {//startif1

      var SCCP_ASPfield_GlobalTitle tmpGT := pl_ASPAddress.globalTitle;


      if (ischosen(tmpGT.gti0010))
      {
        vl_PDUAddress.globalTitle.gti0010.translationType:=tmpGT.gti0010.translationType;
        vl_PDUAddress.globalTitle.gti0010.globalTitleAddress:=tmpGT.gti0010.globalTitleAddress;
      }
      else if (ischosen(tmpGT.gti0011)) //ansi gti001, meaning:
                                        //used GT: SCCP_field_GlobalTitle_TT_NP_ES
      {
        //the left side is ANSI!!!:
        vl_PDUAddress.globalTitle.gti0001.translationType:=tmpGT.gti0011.translationType;
        vl_PDUAddress.globalTitle.gti0001.encodingScheme:=tmpGT.gti0011.encodingScheme;
        vl_PDUAddress.globalTitle.gti0001.numberingPlan:=tmpGT.gti0011.numberingPlan;
        vl_PDUAddress.globalTitle.gti0001.globalTitleAddress:=tmpGT.gti0011.globalTitleAddress;
      };

    }
    else
    {
        vl_PDUAddress.globalTitle := omit;
    };

    // SCCP_param_CPartyAddress_ansi -> octetstring
    vl_PDUAddressEncoded.addr:= enc_PDU_SCCP_Address_ansi( vl_PDUAddress);
    vl_PDUAddressEncoded.paramLength:= lengthof(vl_PDUAddressEncoded.addr);

    return vl_PDUAddressEncoded

  } //ConvertASPAddressToEncodedAddress_ansi

  // ttc national:

  function ConvertASPAddressToEncodedAddress_ttc( in SCCP_PAR_Address pl_ASPAddress)
    runs on SCCP_CT
    return SCCP_param_CPartyAddressEnc
  {

    var SCCP_param_CPartyAddress_ttc vl_PDUAddress; //structured fit to encoding
    var SCCP_param_CPartyAddressEnc vl_PDUAddressEncoded;

    vl_PDUAddress.addressIndicator.pointCodeIndic:=
      pl_ASPAddress.addressIndicator.pointCodeIndic;

    vl_PDUAddress.addressIndicator.ssnIndicator:=
      pl_ASPAddress.addressIndicator.ssnIndicator;

    vl_PDUAddress.addressIndicator.globalTitleIndic:=
     pl_ASPAddress.addressIndicator.globalTitleIndic;

    vl_PDUAddress.addressIndicator.routingIndicator:=
      pl_ASPAddress.addressIndicator.routingIndicator;

    vl_PDUAddress.addressIndicator.reserved:='1'B;

    //----signPointCode handling
    if ( ispresent( pl_ASPAddress.signPointCode )) {
      vl_PDUAddress.signPointCode := pl_ASPAddress.signPointCode;
    } else {
      vl_PDUAddress.signPointCode := omit;
    };

    //----subsystemNumber handling
    if ( ispresent( pl_ASPAddress.subsystemNumber ) ){
      vl_PDUAddress.subsystemNumber:= pl_ASPAddress.subsystemNumber;
    } else {
      vl_PDUAddress.subsystemNumber :=omit;
    };

    // --- globalTitle handling--
    if ( ispresent(pl_ASPAddress.globalTitle))
    {//startif1

      var SCCP_ASPfield_GlobalTitle tmpGT ;
      tmpGT := pl_ASPAddress.globalTitle;

      if (ischosen(tmpGT.gti0001))
      {
        vl_PDUAddress.globalTitle.gti0001.natureOfAddress:=tmpGT.gti0001.natureOfAddress;
        vl_PDUAddress.globalTitle.gti0001.oddeven:=tmpGT.gti0001.oddeven;
        vl_PDUAddress.globalTitle.gti0001.globalTitleAddress:=tmpGT.gti0001.globalTitleAddress;
      }
      else if (ischosen(tmpGT.gti0010))
      {
        vl_PDUAddress.globalTitle.gti0010.translationType:=tmpGT.gti0010.translationType;
        vl_PDUAddress.globalTitle.gti0010.globalTitleAddress:=tmpGT.gti0010.globalTitleAddress;
      }
      else if (ischosen(tmpGT.gti0011))
      {
        vl_PDUAddress.globalTitle.gti0011.translationType:=tmpGT.gti0011.translationType;
        vl_PDUAddress.globalTitle.gti0011.encodingScheme:=tmpGT.gti0011.encodingScheme;
        vl_PDUAddress.globalTitle.gti0011.numberingPlan:=tmpGT.gti0011.numberingPlan;
        vl_PDUAddress.globalTitle.gti0011.globalTitleAddress:=tmpGT.gti0011.globalTitleAddress;
      }
      else if (ischosen(tmpGT.gti0100))
      {
        vl_PDUAddress.globalTitle.gti0100.translationType:=tmpGT.gti0100.translationType;
        vl_PDUAddress.globalTitle.gti0100.encodingScheme:=tmpGT.gti0100.encodingScheme;
        vl_PDUAddress.globalTitle.gti0100.numberingPlan:=tmpGT.gti0100.numberingPlan;
        vl_PDUAddress.globalTitle.gti0100.natureOfAddress:=tmpGT.gti0100.natureOfAddress;
        vl_PDUAddress.globalTitle.gti0100.reserved:='0'B;
        vl_PDUAddress.globalTitle.gti0100.globalTitleAddress:=tmpGT.gti0100.globalTitleAddress;
      };
    }
    else
    {
        vl_PDUAddress.globalTitle := omit;
    };

    vl_PDUAddressEncoded.addr:= enc_PDU_SCCP_Address_ttc( vl_PDUAddress);
    vl_PDUAddressEncoded.paramLength:= lengthof(vl_PDUAddressEncoded.addr);

    return vl_PDUAddressEncoded;

  } //ConvertASPAddressToEncodedAddress_ttc

  // mpt national:

  function ConvertASPAddressToEncodedAddress_mpt( in SCCP_PAR_Address pl_ASPAddress)
    runs on SCCP_CT
    return SCCP_param_CPartyAddressEnc
  {

    var SCCP_param_CPartyAddress_mpt vl_PDUAddress; //structured fit to encoding
    var SCCP_param_CPartyAddressEnc vl_PDUAddressEncoded;

    vl_PDUAddress.addressIndicator.pointCodeIndic:=
      pl_ASPAddress.addressIndicator.pointCodeIndic;

    vl_PDUAddress.addressIndicator.ssnIndicator:=
      pl_ASPAddress.addressIndicator.ssnIndicator;

    vl_PDUAddress.addressIndicator.globalTitleIndic:=
     pl_ASPAddress.addressIndicator.globalTitleIndic;

    vl_PDUAddress.addressIndicator.routingIndicator:=
      pl_ASPAddress.addressIndicator.routingIndicator;

    vl_PDUAddress.addressIndicator.reserved:='1'B;

    //----signPointCode handling
    if ( ispresent( pl_ASPAddress.signPointCode )) {
      vl_PDUAddress.signPointCode := pl_ASPAddress.signPointCode;
    } else {
      vl_PDUAddress.signPointCode := omit;
    };

    //----subsystemNumber handling
    if ( ispresent( pl_ASPAddress.subsystemNumber ) ){
      vl_PDUAddress.subsystemNumber:= pl_ASPAddress.subsystemNumber;
    } else {
      vl_PDUAddress.subsystemNumber :=omit;
    };

    // --- globalTitle handling--
    if ( ispresent(pl_ASPAddress.globalTitle))
    {//startif1

      var SCCP_ASPfield_GlobalTitle tmpGT ;
      tmpGT := pl_ASPAddress.globalTitle;

      if (ischosen(tmpGT.gti0001))
      {
        vl_PDUAddress.globalTitle.gti0001.natureOfAddress:=tmpGT.gti0001.natureOfAddress;
        vl_PDUAddress.globalTitle.gti0001.oddeven:=tmpGT.gti0001.oddeven;
        vl_PDUAddress.globalTitle.gti0001.globalTitleAddress:=tmpGT.gti0001.globalTitleAddress;
      }
      else if (ischosen(tmpGT.gti0010))
      {
        vl_PDUAddress.globalTitle.gti0010.translationType:=tmpGT.gti0010.translationType;
        vl_PDUAddress.globalTitle.gti0010.globalTitleAddress:=tmpGT.gti0010.globalTitleAddress;
      }
      else if (ischosen(tmpGT.gti0011))
      {
        vl_PDUAddress.globalTitle.gti0011.translationType:=tmpGT.gti0011.translationType;
        vl_PDUAddress.globalTitle.gti0011.encodingScheme:=tmpGT.gti0011.encodingScheme;
        vl_PDUAddress.globalTitle.gti0011.numberingPlan:=tmpGT.gti0011.numberingPlan;
        vl_PDUAddress.globalTitle.gti0011.globalTitleAddress:=tmpGT.gti0011.globalTitleAddress;
      }
      else if (ischosen(tmpGT.gti0100))
      {
        vl_PDUAddress.globalTitle.gti0100.translationType:=tmpGT.gti0100.translationType;
        vl_PDUAddress.globalTitle.gti0100.encodingScheme:=tmpGT.gti0100.encodingScheme;
        vl_PDUAddress.globalTitle.gti0100.numberingPlan:=tmpGT.gti0100.numberingPlan;
        vl_PDUAddress.globalTitle.gti0100.natureOfAddress:=tmpGT.gti0100.natureOfAddress;
        vl_PDUAddress.globalTitle.gti0100.reserved:='0'B;
        vl_PDUAddress.globalTitle.gti0100.globalTitleAddress:=tmpGT.gti0100.globalTitleAddress;
      };
    }
    else
    {
        vl_PDUAddress.globalTitle := omit;
    };

    vl_PDUAddressEncoded.addr:= enc_PDU_SCCP_Address_mpt( vl_PDUAddress);
    vl_PDUAddressEncoded.paramLength:= lengthof(vl_PDUAddressEncoded.addr);

    return vl_PDUAddressEncoded;

  } //ConvertASPAddressToEncodedAddress_mpt

  //******************************************************************

  //******************************************************************
  // CONVERSION / DECODING
  //******************************************************************

  //******************************************************************
  // function ConvertPDUEncodedAddressToASPAddress_itu
  // converts Encoded PDU Address into sturctured ASP Address
  // according to ITU
  //******************************************************************
  function ConvertPDUEncodedAddressToASPAddress_itu( in SCCP_param_CPartyAddressEnc pl_PDUAddress)
    runs on SCCP_CT return SCCP_PAR_Address
  {
    var SCCP_PAR_Address  vl_ASPAddress;
    var SCCP_ASPfield_GlobalTitle tmpGT; // the same for itu, ansi and ttc
    var SCCP_param_CPartyAddress_itu vl_PDUAddress;

    //new code detail (ethbaat 2003.11.04:
    // decoding from octetstring to structure "SCCP_param_CPartyAddress_itu":
    vl_PDUAddress := dec_PDU_SCCP_Address_itu( pl_PDUAddress.addr );

    vl_ASPAddress.addressIndicator.pointCodeIndic   :=
      vl_PDUAddress.addressIndicator.pointCodeIndic;

    vl_ASPAddress.addressIndicator.ssnIndicator     :=
      vl_PDUAddress.addressIndicator.ssnIndicator;

    vl_ASPAddress.addressIndicator.globalTitleIndic :=
      vl_PDUAddress.addressIndicator.globalTitleIndic;

    vl_ASPAddress.addressIndicator.routingIndicator :=
      vl_PDUAddress.addressIndicator.routingIndicator;

    if (ispresent ( vl_PDUAddress.signPointCode)) {
       vl_ASPAddress.signPointCode:= substr(vl_PDUAddress.signPointCode,2,14);
    }
    else   {
      vl_ASPAddress.signPointCode := omit; //ethbaat 2003.11.04
    }

    if (ispresent (vl_PDUAddress.subsystemNumber )) {  //always suggested ...
      vl_ASPAddress.subsystemNumber:= vl_PDUAddress.subsystemNumber;
    }
    else {
      vl_ASPAddress.subsystemNumber:=omit;  //ethbaat 2003.11.04
    }

    if( ispresent( vl_PDUAddress.globalTitle ) ){
      if  (ischosen (vl_PDUAddress.globalTitle.gti0001))
      {
        tmpGT.gti0001.natureOfAddress:=vl_PDUAddress.globalTitle.gti0001.natureOfAddress;
        tmpGT.gti0001.oddeven:=vl_PDUAddress.globalTitle.gti0001.oddeven;
        tmpGT.gti0001.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0001.globalTitleAddress;
        vl_ASPAddress.globalTitle:=tmpGT;
      }
      else if  (ischosen (vl_PDUAddress.globalTitle.gti0010))
      {
        tmpGT.gti0010.translationType:=vl_PDUAddress.globalTitle.gti0010.translationType;
        tmpGT.gti0010.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0010.globalTitleAddress;
        vl_ASPAddress.globalTitle:=tmpGT;
      }
      else if  (ischosen (vl_PDUAddress.globalTitle.gti0011))
      {
        tmpGT.gti0011.translationType   :=vl_PDUAddress.globalTitle.gti0011.translationType;
        tmpGT.gti0011.encodingScheme    :=vl_PDUAddress.globalTitle.gti0011.encodingScheme;
        tmpGT.gti0011.numberingPlan     :=vl_PDUAddress.globalTitle.gti0011.numberingPlan;
        tmpGT.gti0011.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0011.globalTitleAddress;
        vl_ASPAddress.globalTitle     :=tmpGT;
      }
      else if  (ischosen (vl_PDUAddress.globalTitle.gti0100))
      {
        tmpGT.gti0100.translationType   :=vl_PDUAddress.globalTitle.gti0100.translationType;
        tmpGT.gti0100.encodingScheme    :=vl_PDUAddress.globalTitle.gti0100.encodingScheme;
        tmpGT.gti0100.numberingPlan     :=vl_PDUAddress.globalTitle.gti0100.numberingPlan;
        tmpGT.gti0100.natureOfAddress   :=vl_PDUAddress.globalTitle.gti0100.natureOfAddress
        //tmpGT.gti0100.reserved:='00'B;
        tmpGT.gti0100.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0100.globalTitleAddress;
        vl_ASPAddress.globalTitle     :=tmpGT;
      }
    }
    else
    {
      vl_ASPAddress.globalTitle:= omit;
    };

    return vl_ASPAddress;
  } //ConvertPDUEncodedAddressToASPAddress_itu

  //******************************************************************
  // function ConvertPDUEncodedAddressToASPAddress_ansi
  // converts Encoded PDU Address into sturctured ASP Address
  // according to ANSI
  //******************************************************************

  function ConvertPDUEncodedAddressToASPAddress_ansi( in SCCP_param_CPartyAddressEnc pl_PDUAddress)
    runs on SCCP_CT return SCCP_PAR_Address
  {
    var SCCP_PAR_Address  vl_ASPAddress;
    var SCCP_ASPfield_GlobalTitle tmpGT; // the same for itu, ansi and ttc
    var SCCP_param_CPartyAddress_ansi vl_PDUAddress;

    //new code detail (ethbaat 2003.11.04:
    // decoding from octetstring to structure "SCCP_param_CPartyAddress_itu":
    vl_PDUAddress := dec_PDU_SCCP_Address_ansi( pl_PDUAddress.addr );

    vl_ASPAddress.addressIndicator.pointCodeIndic   :=
      vl_PDUAddress.addressIndicator.pointCodeIndic;

    vl_ASPAddress.addressIndicator.ssnIndicator     :=
      vl_PDUAddress.addressIndicator.ssnIndicator;

    vl_ASPAddress.addressIndicator.globalTitleIndic :=
      vl_PDUAddress.addressIndicator.globalTitleIndic;

    vl_ASPAddress.addressIndicator.routingIndicator :=
      vl_PDUAddress.addressIndicator.routingIndicator;

    if (ispresent (vl_PDUAddress.signPointCode )) {
      vl_ASPAddress.signPointCode:=  vl_PDUAddress.signPointCode;
    }
    else   {
     //vl_ASPAddress.signPointCode.pointCode:='0000000000000000'B; //or empty??? ( 16len bitstring
     vl_ASPAddress.signPointCode:= omit; //ethbaat 2003.11.11
    }

    if (ispresent (vl_PDUAddress.subsystemNumber)) {  //always suggested ...
      vl_ASPAddress.subsystemNumber:= vl_PDUAddress.subsystemNumber;
    }
    else {
      vl_ASPAddress.subsystemNumber:=omit;  //ethbaat 2003.11.04
      //vl_ASPAddress.subsystemNumber:= 0;
    };

    if( ispresent( vl_PDUAddress.globalTitle ) ){
      if  (ischosen (vl_PDUAddress.globalTitle.gti0001))
      {
        tmpGT.gti0011.translationType   :=vl_PDUAddress.globalTitle.gti0001.translationType;
        tmpGT.gti0011.encodingScheme    :=vl_PDUAddress.globalTitle.gti0001.encodingScheme;
        tmpGT.gti0011.numberingPlan     :=vl_PDUAddress.globalTitle.gti0001.numberingPlan;
        tmpGT.gti0011.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0001.globalTitleAddress;
        vl_ASPAddress.globalTitle     :=tmpGT;
      }
      if  (ischosen (vl_PDUAddress.globalTitle.gti0010))
      {
        tmpGT.gti0010.translationType:=vl_PDUAddress.globalTitle.gti0010.translationType;
        tmpGT.gti0010.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0010.globalTitleAddress;
        vl_ASPAddress.globalTitle:=tmpGT;
      };
    }
    else
    {
      vl_ASPAddress.globalTitle:= omit;
    };

    return vl_ASPAddress;
  } //ConvertPDUEncodedAddressToASPAddress_ansi

  //******************************************************************
  // function ConvertPDUEncodedAddressToASPAddress_ttc
  // converts Encoded PDU Address into sturctured ASP Address
  // according to ttc
  //******************************************************************
  function ConvertPDUEncodedAddressToASPAddress_ttc( in SCCP_param_CPartyAddressEnc pl_PDUAddress)
    runs on SCCP_CT return SCCP_PAR_Address
  {
    var SCCP_PAR_Address  vl_ASPAddress;
    var SCCP_ASPfield_GlobalTitle tmpGT; // the same for itu, ansi and ttc
    var SCCP_param_CPartyAddress_ttc vl_PDUAddress;

    //new code detail (ethbaat 2003.11.04:
    // decoding from octetstring to structure "SCCP_param_CPartyAddress_itu":
    vl_PDUAddress := dec_PDU_SCCP_Address_ttc( pl_PDUAddress.addr );

    vl_ASPAddress.addressIndicator.pointCodeIndic   :=
      vl_PDUAddress.addressIndicator.pointCodeIndic;

    vl_ASPAddress.addressIndicator.ssnIndicator     :=
      vl_PDUAddress.addressIndicator.ssnIndicator;

    vl_ASPAddress.addressIndicator.globalTitleIndic :=
      vl_PDUAddress.addressIndicator.globalTitleIndic;

    vl_ASPAddress.addressIndicator.routingIndicator :=
      vl_PDUAddress.addressIndicator.routingIndicator;

    if (ispresent ( vl_PDUAddress.signPointCode)) {
       vl_ASPAddress.signPointCode:= vl_PDUAddress.signPointCode; //old:substr(vl_PDUAddress.signPointCode,2,16);
    }
    else   {
      vl_ASPAddress.signPointCode := omit; //ethbaat 2003.11.04
    }

    if (ispresent (vl_PDUAddress.subsystemNumber )) {  //always suggested ...
      vl_ASPAddress.subsystemNumber:= vl_PDUAddress.subsystemNumber;
    }
    else {
      vl_ASPAddress.subsystemNumber:=omit;  //ethbaat 2003.11.04
    }

    if( ispresent( vl_PDUAddress.globalTitle)){
      if  (ischosen (vl_PDUAddress.globalTitle.gti0001))
      {
        tmpGT.gti0001.natureOfAddress:=vl_PDUAddress.globalTitle.gti0001.natureOfAddress;
        tmpGT.gti0001.oddeven:=vl_PDUAddress.globalTitle.gti0001.oddeven;
        tmpGT.gti0001.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0001.globalTitleAddress;
        vl_ASPAddress.globalTitle:=tmpGT;
      }
      else if  (ischosen (vl_PDUAddress.globalTitle.gti0010))
      {
        tmpGT.gti0010.translationType:=vl_PDUAddress.globalTitle.gti0010.translationType;
        tmpGT.gti0010.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0010.globalTitleAddress;
        vl_ASPAddress.globalTitle:=tmpGT;
      }
      else if  (ischosen (vl_PDUAddress.globalTitle.gti0011))
      {
        tmpGT.gti0011.translationType   :=vl_PDUAddress.globalTitle.gti0011.translationType;
        tmpGT.gti0011.encodingScheme    :=vl_PDUAddress.globalTitle.gti0011.encodingScheme;
        tmpGT.gti0011.numberingPlan     :=vl_PDUAddress.globalTitle.gti0011.numberingPlan;
        tmpGT.gti0011.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0011.globalTitleAddress;
        vl_ASPAddress.globalTitle     :=tmpGT;
      }
      else if  (ischosen (vl_PDUAddress.globalTitle.gti0100))
      {
        tmpGT.gti0100.translationType   :=vl_PDUAddress.globalTitle.gti0100.translationType;
        tmpGT.gti0100.encodingScheme    :=vl_PDUAddress.globalTitle.gti0100.encodingScheme;
        tmpGT.gti0100.numberingPlan     :=vl_PDUAddress.globalTitle.gti0100.numberingPlan;
        tmpGT.gti0100.natureOfAddress   :=vl_PDUAddress.globalTitle.gti0100.natureOfAddress;
        //tmpGT.gti0100.reserved:='00'B;
        tmpGT.gti0100.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0100.globalTitleAddress;
        vl_ASPAddress.globalTitle     :=tmpGT;
      };
    }
    else
    {
      vl_ASPAddress.globalTitle:= omit;
    };

    return vl_ASPAddress;
  } //ConvertPDUEncodedAddressToASPAddress_ttc

  //******************************************************************
  // function ConvertPDUEncodedAddressToASPAddress_mpt
  // converts Encoded PDU Address into sturctured ASP Address
  // according to mpt
  //******************************************************************
  function ConvertPDUEncodedAddressToASPAddress_mpt( in SCCP_param_CPartyAddressEnc pl_PDUAddress)
    runs on SCCP_CT return SCCP_PAR_Address
  {
    var SCCP_PAR_Address  vl_ASPAddress;
    var SCCP_ASPfield_GlobalTitle tmpGT; // the same for itu, ansi and ttc
    var SCCP_param_CPartyAddress_mpt vl_PDUAddress;

    vl_PDUAddress := dec_PDU_SCCP_Address_mpt( pl_PDUAddress.addr );

    vl_ASPAddress.addressIndicator.pointCodeIndic   :=
      vl_PDUAddress.addressIndicator.pointCodeIndic;

    vl_ASPAddress.addressIndicator.ssnIndicator     :=
      vl_PDUAddress.addressIndicator.ssnIndicator;

    vl_ASPAddress.addressIndicator.globalTitleIndic :=
      vl_PDUAddress.addressIndicator.globalTitleIndic;

    vl_ASPAddress.addressIndicator.routingIndicator :=
      vl_PDUAddress.addressIndicator.routingIndicator;

    if (ispresent ( vl_PDUAddress.signPointCode)) {
       vl_ASPAddress.signPointCode:= vl_PDUAddress.signPointCode;
    }
    else   {
      vl_ASPAddress.signPointCode := omit;
    }

    if (ispresent (vl_PDUAddress.subsystemNumber )) {  //always suggested ...
      vl_ASPAddress.subsystemNumber:= vl_PDUAddress.subsystemNumber;
    }
    else {
      vl_ASPAddress.subsystemNumber:=omit;
    }

    if( ispresent( vl_PDUAddress.globalTitle)){
      if  (ischosen (vl_PDUAddress.globalTitle.gti0001))
      {
        tmpGT.gti0001.natureOfAddress:=vl_PDUAddress.globalTitle.gti0001.natureOfAddress;
        tmpGT.gti0001.oddeven:=vl_PDUAddress.globalTitle.gti0001.oddeven;
        tmpGT.gti0001.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0001.globalTitleAddress;
        vl_ASPAddress.globalTitle:=tmpGT;
      }
      else if  (ischosen (vl_PDUAddress.globalTitle.gti0010))
      {
        tmpGT.gti0010.translationType:=vl_PDUAddress.globalTitle.gti0010.translationType;
        tmpGT.gti0010.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0010.globalTitleAddress;
        vl_ASPAddress.globalTitle:=tmpGT;
      }
      else if  (ischosen (vl_PDUAddress.globalTitle.gti0011))
      {
        tmpGT.gti0011.translationType   :=vl_PDUAddress.globalTitle.gti0011.translationType;
        tmpGT.gti0011.encodingScheme    :=vl_PDUAddress.globalTitle.gti0011.encodingScheme;
        tmpGT.gti0011.numberingPlan     :=vl_PDUAddress.globalTitle.gti0011.numberingPlan;
        tmpGT.gti0011.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0011.globalTitleAddress;
        vl_ASPAddress.globalTitle     :=tmpGT;
      }
      else if  (ischosen (vl_PDUAddress.globalTitle.gti0100))
      {
        tmpGT.gti0100.translationType   :=vl_PDUAddress.globalTitle.gti0100.translationType;
        tmpGT.gti0100.encodingScheme    :=vl_PDUAddress.globalTitle.gti0100.encodingScheme;
        tmpGT.gti0100.numberingPlan     :=vl_PDUAddress.globalTitle.gti0100.numberingPlan;
        tmpGT.gti0100.natureOfAddress   :=vl_PDUAddress.globalTitle.gti0100.natureOfAddress;
        //tmpGT.gti0100.reserved:='00'B;
        tmpGT.gti0100.globalTitleAddress:=vl_PDUAddress.globalTitle.gti0100.globalTitleAddress;
        vl_ASPAddress.globalTitle     :=tmpGT;
      };
    }
    else
    {
      vl_ASPAddress.globalTitle:= omit;
    };

    return vl_ASPAddress;
  } //ConvertPDUEncodedAddressToASPAddress_mpt

  //==================================================================
  // MAIN CONVERSION FUNCTIONS:
  //==================================================================

  //******************************************************************
  //  function ConvertASPAddressToEncodedAddress
  //  converts ASP address structure to PDU address structure
  //  THIS IS THE MAIN ENCODE FUNCTION (coordinator)
  //******************************************************************

  function ConvertASPAddressToEncodedAddress( in SCCP_PAR_Address pl_ASPAddress)
    runs on SCCP_CT return SCCP_param_CPartyAddressEnc
  {
      var SCCP_param_CPartyAddressEnc vl_PDUAddressEncoded;
      if( ( v_SCCPServiceType == mtp3_itu) or
          ( v_SCCPServiceType == mtp3b_itu))
      {
         return  ConvertASPAddressToEncodedAddress_itu( pl_ASPAddress );
      }
      else if(  (v_SCCPServiceType == mtp3_ansi) or
                (v_SCCPServiceType == mtp3b_ansi))
      {
        return ConvertASPAddressToEncodedAddress_ansi( pl_ASPAddress );
      }
      else if((v_SCCPServiceType == mtp3_ttc) or
              (v_SCCPServiceType == mtp3b_ttc))
      {
        if( (v_SIO == '83'O) or (v_SIO == '43'O) or (v_SIO == 'C3'O) ) //ttc national
        {
          return ConvertASPAddressToEncodedAddress_ttc( pl_ASPAddress );
        }
        else
        { //international == itu
          return  ConvertASPAddressToEncodedAddress_itu( pl_ASPAddress );
        }
      }//if1
      else if((v_SCCPServiceType == mtp3_mpt))
      {
        if( v_NI == 2 ) //mpt national
        {
          return ConvertASPAddressToEncodedAddress_mpt( pl_ASPAddress );
        }
        else
        { //international == itu
          return  ConvertASPAddressToEncodedAddress_itu( pl_ASPAddress );
        }
      }//if1
      else {
        log("Error in ConvertASPAddressToEncodedAddress: Unknown SCCPServiceType");
        stop;
      }
      return vl_PDUAddressEncoded; // error!!!
  }

  //******************************************************************
  // function ConvertPDUEncodedAddressToASPAddress
  // converts Encoded PDU Address into sturctured ASP Address
  // THIS IS THE MAIN DECODE FUNCTION (coordinator)
  //******************************************************************


  function ConvertPDUEncodedAddressToASPAddress( in SCCP_param_CPartyAddressEnc pl_PDUAddress)
  runs on SCCP_CT return SCCP_PAR_Address
  {
    var SCCP_PAR_Address vl_dummyretval;

    if( (v_SCCPServiceType == mtp3_itu) or
        (v_SCCPServiceType == mtp3b_itu) )
    {
      return  ConvertPDUEncodedAddressToASPAddress_itu( pl_PDUAddress );
    }
    else if( (v_SCCPServiceType == mtp3_ansi) or
             (v_SCCPServiceType == mtp3b_ansi) )
    {
      return  ConvertPDUEncodedAddressToASPAddress_ansi( pl_PDUAddress );
    }
    else if( (v_SCCPServiceType == mtp3_ttc) or
             (v_SCCPServiceType == mtp3b_ttc)){
      if( (v_SIO == '83'O) or (v_SIO == '43'O) or (v_SIO == 'C3'O) )
      {
        //ttc national
        return ConvertPDUEncodedAddressToASPAddress_ttc( pl_PDUAddress );
      }
      else {
        return  ConvertPDUEncodedAddressToASPAddress_itu( pl_PDUAddress );
      }
    }
    else if((v_SCCPServiceType == mtp3_mpt))
    {
      if( v_NI == 2 ) //mpt national
      {
        return ConvertPDUEncodedAddressToASPAddress_mpt( pl_PDUAddress );
      }
      else
      { //international == itu
        return  ConvertPDUEncodedAddressToASPAddress_itu( pl_PDUAddress );
      }
    }
    else {
      log("Error in function ConvertPDUEncodedAddressToASPAddress, Unknown SCCPSCCPType");
      stop;
    }
    return vl_dummyretval;
  }//ConvertPDUEncodedAddressToASPAddress
/*
//*************************************************************************
//*************************************************************************
//EncDec ComponentBehaviour
//*************************************************************************
//*************************************************************************

  // TO DO:Desk check it! As I see, it's OK, but the meaning has been changed\
  // because structure of PDU_SCCP has been changed

  //*************************************************************************
  function ScanRAWPorts()  runs on SCCP_EncDec_CT
  //*************************************************************************
  {
    //local declarations
  var  ASP_MTP3_TRANSFERind vl_ASP_MTP3_TRANSFERind;
  var  ASP_MTP3_TRANSFERreq vl_ASP_MTP3_TRANSFERreq;
  var  ASP_MTP3_TRANSFERreq_sccp vl_ASP_MTP3_TRANSFERreq_sccp

  var  PDU_SCCP   vl_PDU_SCCP;
  var  integer    vl_msg_type;

  while (true)
  {
    alt
    {

    //********************************************************************
    //message received from SCCP , containing a PDU to be encoded
    //********************************************************************

      []MTP3_SCCP_SP_PORT.receive( tr_ASP_MTP3_TRANSFERreq_sccp) -> value vl_ASP_MTP3_TRANSFERreq_sccp
        {
          var bitstring vl_sio_bit := oct2bit(vl_ASP_MTP3_TRANSFERreq_sccp.sio);
          var MTP3_Field_sio vl_sio_struct;
          vl_sio_struct.ni := substr(vl_sio_bit,0,2);
          vl_sio_struct.prio := substr(vl_sio_bit,2,2);
          vl_sio_struct.si := substr(vl_sio_bit,4,4);

          MTP3_PORT.send(t_ASP_MTP3_TRANSFERreq(
            vl_sio_struct,
            vl_ASP_MTP3_TRANSFERreq_sccp.opc,
            vl_ASP_MTP3_TRANSFERreq_sccp.dpc,
            vl_ASP_MTP3_TRANSFERreq_sccp.sls,
            enc_PDU_SCCP(vl_ASP_MTP3_TRANSFERreq_sccp.data)
          ));
        }

      //********************************************************************
      //message received from MTP3 , containing an octetstring to be decoded:
      //********************************************************************

      []MTP3_PORT.receive(tr_ASP_MTP3_TRANSFERind) -> value  vl_ASP_MTP3_TRANSFERind
        {//startStatementBlock
          if (vl_ASP_MTP3_TRANSFERind.sio.si != '0011'B)
          {
            log("The received message is not SCCP. Ignored.");
            repeat;
          }
          vl_msg_type:= oct2int( vl_ASP_MTP3_TRANSFERind.data[0] );

          select(vl_msg_type)
          {
            case (xudt)  // '11'O
            {
              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);
              MTP3_SCCP_SP_PORT.send( vl_PDU_SCCP.extudata );
            }
            case (udt) //'09'O
            {
              //decode octetstring
              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

              MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_Unitdata(
                    vl_PDU_SCCP.unitdata.protClass,
                    vl_PDU_SCCP.unitdata.calledPAddress,
                    vl_PDU_SCCP.unitdata.callingPAddress,
                    vl_PDU_SCCP.unitdata.data));

            }//endif
            case (dt1)//'06'O
            {
              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

              MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_DataForm1(
                  vl_PDU_SCCP.dataform1.destLocRef,
                  vl_PDU_SCCP.dataform1.segmentingReassembl,
                  vl_PDU_SCCP.dataform1.data
                  ));
            }
            case (cr) //'01'O
            {//startif
              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

              if (ispresent(vl_PDU_SCCP.connrequest.eop))
              {
                MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_ConnectionRequest(
                      vl_PDU_SCCP.connrequest.sourceLocRef,
                      vl_PDU_SCCP.connrequest.protClass,
                      vl_PDU_SCCP.connrequest.calledPAddress,
                      vl_PDU_SCCP.connrequest.optionalPart.credit,
                      vl_PDU_SCCP.connrequest.optionalPart.callingPAddress,
                      vl_PDU_SCCP.connrequest.optionalPart.data,
                      vl_PDU_SCCP.connrequest.optionalPart.hopCounter,
                      vl_PDU_SCCP.connrequest.optionalPart.importance,
                      vl_PDU_SCCP.connrequest.eop
                ));
              }
              else
              {
                MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_ConnectionRequest(
                      vl_PDU_SCCP.connrequest.sourceLocRef,
                      vl_PDU_SCCP.connrequest.protClass,
                      vl_PDU_SCCP.connrequest.calledPAddress,
                      vl_PDU_SCCP.connrequest.optionalPart.credit,
                      vl_PDU_SCCP.connrequest.optionalPart.callingPAddress,
                      vl_PDU_SCCP.connrequest.optionalPart.data,
                      vl_PDU_SCCP.connrequest.optionalPart.hopCounter,
                      vl_PDU_SCCP.connrequest.optionalPart.importance,
                      omit
                ));
              }

            }
            case (cc) //'02'O
            {
              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

              if (ispresent(vl_PDU_SCCP.connconfirm.eop))
              {
                MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_ConnectionConfirm(
                      vl_PDU_SCCP.connconfirm.destLocRef,
                      vl_PDU_SCCP.connconfirm.sourceLocRef,
                      vl_PDU_SCCP.connconfirm.protClass,
                      vl_PDU_SCCP.connconfirm.optionalPart.credit,
                      vl_PDU_SCCP.connconfirm.optionalPart.calledPAddress,
                      vl_PDU_SCCP.connconfirm.optionalPart.data,
                      vl_PDU_SCCP.connconfirm.optionalPart.importance,
                      vl_PDU_SCCP.connconfirm.eop                  ));
              }
              else
              {
                MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_ConnectionConfirm(
                      vl_PDU_SCCP.connconfirm.destLocRef,
                      vl_PDU_SCCP.connconfirm.sourceLocRef,
                      vl_PDU_SCCP.connconfirm.protClass,
                      vl_PDU_SCCP.connconfirm.optionalPart.credit,
                      vl_PDU_SCCP.connconfirm.optionalPart.calledPAddress,
                      vl_PDU_SCCP.connconfirm.optionalPart.data,
                      vl_PDU_SCCP.connconfirm.optionalPart.importance,
                      omit));
              }

            }
            case (udts) //'0A'O
          {//startif
            vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

            MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_UnitdataService(
                  vl_PDU_SCCP.udataserv.returnCause,
                  vl_PDU_SCCP.udataserv.calledPAddress,
                  vl_PDU_SCCP.udataserv.callingPAddress,
                  vl_PDU_SCCP.udataserv.data));

          }//endif
            case (rlsd) //'04'O
            {
              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

              if (ispresent(vl_PDU_SCCP.released.eop))
              {
                MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_Released(
                      vl_PDU_SCCP.released.destLocRef,
                      vl_PDU_SCCP.released.sourceLocRef,
                      vl_PDU_SCCP.released.releaseCause,
                      vl_PDU_SCCP.released.optionalPart.data,
                      vl_PDU_SCCP.released.optionalPart.importance,
                      vl_PDU_SCCP.released.eop
                      ));
              }
              else
              {
                MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_Released(
                      vl_PDU_SCCP.released.destLocRef,
                      vl_PDU_SCCP.released.sourceLocRef,
                      vl_PDU_SCCP.released.releaseCause,
                      vl_PDU_SCCP.released.optionalPart.data,
                      vl_PDU_SCCP.released.optionalPart.importance,
                      omit
                      ));
              }

            }
            case (err)//'0F'O
            {
              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

              MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_ProtDataUnitError(
                    vl_PDU_SCCP.pduerror.destLocRef,
                    vl_PDU_SCCP.pduerror.errorCause
                     ));
            }
            case (rlc)//'05'O
            {
              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

              MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_ReleaseComplete(
                    vl_PDU_SCCP.relcomp.destLocRef,
                    vl_PDU_SCCP.relcomp.sourceLocRef
                    ));
            }
            case (it)//'10'O
            {
                vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

                MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_InactivityTest(
                    vl_PDU_SCCP.inacttest.destLocRef,
                    vl_PDU_SCCP.inacttest.sourceLocRef,
                    vl_PDU_SCCP.inacttest.protClass,
                    vl_PDU_SCCP.inacttest.sequencingSegmenting,
                    vl_PDU_SCCP.inacttest.credit
                    ));
            }
            case (rsr)//'0D'O
            {
              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

              MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_ResetRequest(
                    vl_PDU_SCCP.resetreq.destLocRef,
                    vl_PDU_SCCP.resetreq.sourceLocRef,
                    vl_PDU_SCCP.resetreq.resetCause
                    ));
            }
            case (rsc)//'0E'O
            {

              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

              MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_ResetConfirm(
                    vl_PDU_SCCP.resconf.destLocRef,
                    vl_PDU_SCCP.resconf.sourceLocRef
                    ));
            }//endif
            case (cref)//'03'O
            {
              vl_PDU_SCCP:=dec_PDU_SCCP(vl_ASP_MTP3_TRANSFERind.data);

              if (ispresent(vl_PDU_SCCP.connrefused.eop))
              {
                MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_ConnectionRefused(
                    vl_PDU_SCCP.connrefused.destLocRef,
                    vl_PDU_SCCP.connrefused.refusalCause,
                    vl_PDU_SCCP.connrefused.optionalPart.calledPAddress,
                    vl_PDU_SCCP.connrefused.optionalPart.data,
                    vl_PDU_SCCP.connrefused.optionalPart.importance,
                    vl_PDU_SCCP.connrefused.eop
                    ));
              }
              else
              {
                MTP3_SCCP_SP_PORT.send( t_PDU_SCCP_ConnectionRefused(
                    vl_PDU_SCCP.connrefused.destLocRef,
                    vl_PDU_SCCP.connrefused.refusalCause,
                    vl_PDU_SCCP.connrefused.optionalPart.calledPAddress,
                    vl_PDU_SCCP.connrefused.optionalPart.data,
                    vl_PDU_SCCP.connrefused.optionalPart.importance,
                    omit
                    ));
              }
            }
            case (xudts,ludt,ludts)
            {
              log ("Unsupported connectionless message ((-XUDT or))  XUDTS or LUDT or LUDTS - received and discarded");
            }
            case (dt2,ak,ed,ea )
            {
              log ("Unsupported connection-oriented  message -DT2 or AK or ED or EA - received and discarded");
            }
            case else { log ("Unrecognized message received and discarded"); }
          }
        }//endStatementBlock

      }//endalt

    }//endwhile

  }//endfunction
*/

//******************************************************************
//
//    working functions for ScanEvents
//
//******************************************************************

//******************************************************************
//    Part 1 :  Receiving msg on port "MTP3_SCCP_PORT"
//******************************************************************


  //******************************************************************
  //  processing_PDU_SCCP_Unitdata
  //******************************************************************
  function processing_PDU_SCCP_Unitdata( in PDU_SCCP_Unitdata pl_PDU_SCCP_Unitdata)
  runs on SCCP_CT
  {
    //var   PDU_SCCP_Unitdata vl_PDU_SCCP_Unitdata;
    var   PDU_SCCP          vl_PDU_SCCP;
    var   ASP_SCCP_N_UNITDATA_ind    vl_N_UNITDATA_ind;

    vl_PDU_SCCP.unitdata:= pl_PDU_SCCP_Unitdata;

    // it should be decoded to structure to read if it is a mgmt message or not
    vl_N_UNITDATA_ind.calledAddress :=
      ConvertPDUEncodedAddressToASPAddress(pl_PDU_SCCP_Unitdata.calledPAddress);

    if ( ispresent(vl_N_UNITDATA_ind.calledAddress.subsystemNumber)  and
      vl_N_UNITDATA_ind.calledAddress.subsystemNumber != cg_SSN_sCCPmanagement)
    //SCCP mgmt message
    {//startif1

      //no SCCP or node congestion assumed
      //'route on SSN' assumed

      //subsystems are assumed equipped and available
      //as the message is received from MTP3 , DPC is assumed to be matching the PC of the own node without
      // any further checks

      //assemble ASP_SCCP_N_
      vl_N_UNITDATA_ind.callingAddress:=
        ConvertPDUEncodedAddressToASPAddress(pl_PDU_SCCP_Unitdata.callingPAddress);

      // Wrong old:
      //vl_N_UNITDATA_ind.sequenceControl:=
      //  '0000000'B&pl_PDU_SCCP_Unitdata.protClass.class[0]; // Q.713/3.6  0.bit=1=>seq msb???

      vl_N_UNITDATA_ind.sequenceControl:=
        '0000000'B&pl_PDU_SCCP_Unitdata.protClass.class[3];

      if( pl_PDU_SCCP_Unitdata.protClass.messageHandling == '1000'B )
      { vl_N_UNITDATA_ind.returnOption   := '00000001'B; }
      else
      { vl_N_UNITDATA_ind.returnOption   := '00000000'B; }

      //connectionless-class 0 or 1
      //protocol class 0- SCCP_sequence_ctrl_off
      //protocol class 1- SCCP_sequence_ctrl_on
      // wrong: vl_N_UNITDATA_ind.returnOption       :='0000000'B&pl_PDU_SCCP_Unitdata.protClass.messageHandling[3];

      //only two values( '0000'B -no special options
      //and   '1000'B -return message on error) assumed
      //octetstring                          vs.   length+octetstring
      vl_N_UNITDATA_ind.userData         :=pl_PDU_SCCP_Unitdata.data.data;
      vl_N_UNITDATA_ind.importance := omit;
      SCCP_SP_PORT.send( vl_N_UNITDATA_ind );


    }//endif1
    else { //startelse1-SCCPmanagement message

      log ("SCCP management message received");
      var octetstring  vl_data;
      vl_data:=pl_PDU_SCCP_Unitdata.data.data;

      vl_PDU_SCCP.unitdata.messageType:=udt ;
      vl_PDU_SCCP.unitdata.calledPAddress:=pl_PDU_SCCP_Unitdata.callingPAddress;
      vl_PDU_SCCP.unitdata.callingPAddress:=pl_PDU_SCCP_Unitdata.calledPAddress;

      if ((vl_data[0]=='03'O) and                       //SST message
          ((v_SSN==0) or (oct2int(vl_data[1])==v_SSN))) //right SSN
      {//startif2

        //send Unitdata with SSA
        vl_PDU_SCCP.unitdata.data.data[0]:='01'O;//Change to SSA
        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
            (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Unitdata_SSA

      }//endif2
      else if ((vl_data[0]=='02'O) and                       //SSP message
               ((v_SSN==0) or (oct2int(vl_data[1])==v_SSN))) //right SSN
      {//startif2

        //send Unitdata with SST
        vl_PDU_SCCP.unitdata.data.data[0]:='03'O;//Change to SST
        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
            (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Unitdata_SST

      }//endif2
      else if ((vl_data[0]=='01'O) and                        //SSA message
               ((v_SSN==0) or (oct2int(vl_data[1])==v_SSN)))  //right SSN
      {//startif2

        //send Unitdata with SS
        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP ));//send Unitdata_SSA

      }//endif2
      else
      {
        log("Unsupported (or containing inconsistent SSN)SCCP management message  received and discarded")
      }
    }//endelse1
    return;
  } // processing_PDU_SCCP_Unitdata()

  //******************************************************************
  //  processing_PDU_SCCP_UnitdataService
  //******************************************************************
  function processing_PDU_SCCP_UnitdataService( in PDU_SCCP_UnitdataService pl_PDU_SCCP_UnitdataService )
  runs on SCCP_CT
  {

    var ASP_SCCP_N_NOTICE_ind  vl_N_NOTICE_ind;

    //no SCCP or node congestion assumed
    //'route on SSN' assumed

    //subsystems are assumed equipped and available
    //as the message is received from MTP3 , DPC is assumed to be the PC of the own node without
    // any further checks

    //assemble ASP_SCCP_N_

    vl_N_NOTICE_ind.calledAddress :=ConvertPDUEncodedAddressToASPAddress(pl_PDU_SCCP_UnitdataService.calledPAddress );
    vl_N_NOTICE_ind.callingAddress:=ConvertPDUEncodedAddressToASPAddress(pl_PDU_SCCP_UnitdataService.callingPAddress);
    //one to one mapping between reasonForReturn and returnCause -Q713 A5
    vl_N_NOTICE_ind.reasonForReturn  := pl_PDU_SCCP_UnitdataService.returnCause   ;
    vl_N_NOTICE_ind.userData         := pl_PDU_SCCP_UnitdataService.data.data   ;

    SCCP_SP_PORT.send( t_ASP_N_NOTICE_ind(
      vl_N_NOTICE_ind.calledAddress ,
      vl_N_NOTICE_ind.callingAddress,
      vl_N_NOTICE_ind.reasonForReturn,
      vl_N_NOTICE_ind.userData ,
      omit));

  }// processing_PDU_SCCP_UnitdataService


  //******************************************************************
  //   processing_PDU_SCCP_ConnectionRequest
  //******************************************************************
  function processing_PDU_SCCP_ConnectionRequest( in PDU_SCCP_ConnectionRequest pl_PDU_SCCP_ConnectionRequest)
  runs on SCCP_CT
  {
    //no SCCP or node congestion assumed
    //we assume that routing is done on SSN; we are in the dest.node
    //SS is equipped and available

    //check if connection already established
    //local reference not assigned yet; search has to be done based on remote reference,
    // to prevent erroneous situations
    //for all other MTP3_ASPs, search is done based on destLocRef, containing the local
    //reference sent to the neighbouring node

    if (ConnectionAlreadyEstablished_remote(pl_PDU_SCCP_ConnectionRequest.sourceLocRef))
    {//startif3
      v_session :=Retrieve_session_remote(pl_PDU_SCCP_ConnectionRequest.sourceLocRef);
      //Action Table follows

      if (ConnectionTable[v_session].state==idle)
      { log("CR received with reference for an already established conn. in state:idle");}//no source ref known
      else if (ConnectionTable[v_session].state==active)
      { log("CR received with reference for an already established conn. in state:active");}
      else if (ConnectionTable[v_session].state==reset_bothway)
      { log("CR received with reference for an already established conn. in state:reset_bothway");}
      else if (ConnectionTable[v_session].state==connection_pending_IC)
      { log("CR received with reference for an already established conn. in state:connection_pending_IC");}
      //discard message, return
      else if (ConnectionTable[v_session].state==disconnect_pending)
      { log("CR received with reference for an already established conn. in state:disconnect_pending");}//discard message, return
      else if (ConnectionTable[v_session].state==reset_IC) {//startif4
        //discard received message
        f_StartTimer(internal_reset,v_session,0.0);//the dummy timer times out immediately
        //state changed to active
        ConnectionTable[v_session].state:=active;

      }//endif4
      else if (ConnectionTable[v_session].state==wait_conn_confirm)
      {//startif4
        //stop connection timer
        f_StopTimer(conn_est,v_session);
        //release resources
        ReleaseResources(v_session);
      }//endif4
    }//endif3
    else  {//startelse

      //*************************************************************************
      //connection not yet established  - new v_session
      //check if resources available
      v_session:=CheckIdleIndividuals()

      //idle individual found  , resources available, 0<=v_session<=15
      if ( v_session!=-1 )
      {//startif3
        //
        ConnectionTable[v_session].localReference := GenerateLocalReference();
        ConnectionTable[v_session].remoteReference:= pl_PDU_SCCP_ConnectionRequest.sourceLocRef;
        //local reference assigned here!!(see Fig. C.3/Q714)

        ConnectionTable[v_session].connectionId   := GenerateConnectionId();

        //once local reference is assigned , a session is considered established
        //determine protocol class
        //assemble ASP_SCCP_N_
        //start guard timer T_guard ;if no answer to ASP_SCCP_N_CONNECT_ind is received, timer will release

        var ASP_SCCP_N_CONNECT_ind vl_N_CONNECT_ind;
        f_StartTimer(t_guard,v_session);

        vl_N_CONNECT_ind.calledAddress:=ConvertPDUEncodedAddressToASPAddress(pl_PDU_SCCP_ConnectionRequest.calledPAddress);

        if (ispresent(pl_PDU_SCCP_ConnectionRequest.optionalPart))
        {
          if (ispresent(pl_PDU_SCCP_ConnectionRequest.optionalPart.callingPAddress))
          {//startif4

            //temporary variable to avoid type conversion problems
            var SCCP_param_CPartyAddressEnc  vl_PDUAddress;
            vl_PDUAddress.addr             := pl_PDU_SCCP_ConnectionRequest.optionalPart.callingPAddress.addr;
            vl_PDUAddress.paramLength      := pl_PDU_SCCP_ConnectionRequest.optionalPart.callingPAddress.paramLength;
            vl_N_CONNECT_ind.callingAddress:= ConvertPDUEncodedAddressToASPAddress(vl_PDUAddress);

          }//endif4
          else {vl_N_CONNECT_ind.callingAddress:=omit}

          if (ispresent(pl_PDU_SCCP_ConnectionRequest.optionalPart.data))
          {//startif4
            //temporary variable to avoid type conversion problems
            var SCCP_param_Data_opt  vl_SCCP_param_Data_opt;

            vl_SCCP_param_Data_opt:=pl_PDU_SCCP_ConnectionRequest.optionalPart.data;
            vl_N_CONNECT_ind.userData:=vl_SCCP_param_Data_opt.data;

          }//endif4
          else {vl_N_CONNECT_ind.userData:=omit}
        }
        else
        {
          vl_N_CONNECT_ind.callingAddress:=omit;
          vl_N_CONNECT_ind.userData:=omit;
        }

        vl_N_CONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;

        SCCP_SP_PORT.send( t_ASP_N_CONNECT_ind(
          vl_N_CONNECT_ind.calledAddress,
          vl_N_CONNECT_ind.callingAddress,
          omit,
          vl_N_CONNECT_ind.userData,  //ethcky
          vl_N_CONNECT_ind.connectionId,
          omit));//send ASP_SCCP_N_CONNECT_ind

        //restart send inactivity timer (baat)
        f_StopTimer(ias,v_session);//to avoid warnings
        f_StartTimer(ias,v_session);
        ConnectionTable[v_session].state:=connection_pending_IC;

      }//endif3

      //no idle individual found , no resources available , v_session=-1
      if (v_session==-1)
      {//startif3

        var  PDU_SCCP vl_PDU_SCCP;
        //assemble and route MTP3 ASP
        vl_PDU_SCCP.connrefused.messageType:=cref;
        vl_PDU_SCCP.connrefused.destLocRef:=pl_PDU_SCCP_ConnectionRequest.sourceLocRef;
        vl_PDU_SCCP.connrefused.refusalCause:=1;//End user congestion
        vl_PDU_SCCP.connrefused.pointer1:=0;// No options
        vl_PDU_SCCP.connrefused.optionalPart:=omit;
        vl_PDU_SCCP.connrefused.eop:=omit;
        MTP3_SCCP_PORT.send ( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Connection refused, no idle individuals
        //return to idle
      }//endif3
    }//endelse

  }//processing_PDU_SCCP_ConnectionRequest

//******************************************************************
//  processing_PDU_SCCP_ConnectionConfirm
//******************************************************************
  function processing_PDU_SCCP_ConnectionConfirm( in PDU_SCCP_ConnectionConfirm pl_PDU_SCCP_ConnectionConfirm)
  runs on SCCP_CT
  {
    var PDU_SCCP        vl_PDU_SCCP;
    var ASP_SCCP_N_CONNECT_cfm   vl_N_CONNECT_cfm;

    log(pl_PDU_SCCP_ConnectionConfirm);

    //Store data parameter
    var template SCCP_PAR_UserData tl_data := omit;
    if (ispresent(pl_PDU_SCCP_ConnectionConfirm.optionalPart))
    {
      if (ispresent(pl_PDU_SCCP_ConnectionConfirm.optionalPart.data))
      {
         tl_data := pl_PDU_SCCP_ConnectionConfirm.optionalPart.data.data;
      }
    }

    //check if connection already established
    if (ConnectionAlreadyEstablished(pl_PDU_SCCP_ConnectionConfirm.destLocRef))
    {//startif2
      v_session :=Retrieve_session(pl_PDU_SCCP_ConnectionConfirm.destLocRef);
      //Action Table follows
      if (ConnectionTable[v_session].state==idle)
      {
        //assemble and route MTP3_ASP

        vl_PDU_SCCP.pduerror.messageType:=err;
        vl_PDU_SCCP.pduerror.destLocRef:=ConnectionTable[v_session].remoteReference;
        vl_PDU_SCCP.pduerror.errorCause:=cg_Err_unassignedDestinationLRN;

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Error
        //then return to idle
      }
      else if (ConnectionTable[v_session].state==connection_pending_IC)
      { log("CC received in state:connection_pending_IC"); }//discard message, return
      else if (ConnectionTable[v_session].state==disconnect_pending)
      { log("CC received in state:disconnect_pending"); }//discard message, return
      else if (ConnectionTable[v_session].state==active)
      { log("CC received in state:active"); }//do nothing, return
      else if (ConnectionTable[v_session].state==reset_bothway)
      { log("CC received in state:reset_bothway"); }//
      else if (ConnectionTable[v_session].state==connection_pending_OG)
      {//startif3
        //stop connection timer
        f_StopTimer(conn_est,v_session);
        //start inactivity timers
        f_StartTimer(ias,v_session);
        f_StartTimer(iar,v_session);
        //assign protocol class:=2, associate remote reference
        ConnectionTable[v_session].remoteReference:=pl_PDU_SCCP_ConnectionConfirm.sourceLocRef;
        //assemble ASP_SCCP_N_
        vl_N_CONNECT_cfm.connectionId:=ConnectionTable[v_session].connectionId;

        SCCP_SP_PORT.send( t_ASP_N_CONNECT_cfm(
            omit,
            omit,
            tl_data,
            vl_N_CONNECT_cfm.connectionId,
            omit
            ));//send ASP_SCCP_N_CONNECT_confirm

        ConnectionTable[v_session].state:=active;
      }//endif3
      else if (ConnectionTable[v_session].state==wait_conn_confirm)//connection is confirmed ,
        // but it has meanwhile been disconnected by the user
      {//startif3
        //stop connection timer
        f_StopTimer(conn_est,v_session);
        //associate remote reference to connection
        ConnectionTable[v_session].remoteReference:=pl_PDU_SCCP_ConnectionConfirm.sourceLocRef;
        //assemble and route MTP3_ASP
        vl_PDU_SCCP.released.messageType:=rlsd;
        vl_PDU_SCCP.released.destLocRef:=ConnectionTable[v_session].remoteReference;
        vl_PDU_SCCP.released.sourceLocRef:=ConnectionTable[v_session].localReference;
        vl_PDU_SCCP.released.releaseCause:=cg_DISC_normal;
        vl_PDU_SCCP.released.pointer1:=0;//No options
        vl_PDU_SCCP.released.optionalPart:=omit;
        vl_PDU_SCCP.released.eop:=omit;

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Released
        //start release timer
        f_StartTimer(rel,v_session);
        ConnectionTable[v_session].state:=disconnect_pending;
      }//endif3
      else if (ConnectionTable[v_session].state==reset_IC)
      {//startif3
        //discard received message
        f_StartTimer(internal_reset,v_session,0.0);//the timer times out immediately
        //state changed to active
        ConnectionTable[v_session].state:=active;

      }//endif3
      else { log("CC received in an unexpected state");  }
    }//endif2
    else {//startelse -Connection confirm  received with destLocRef  not in ConnectionTable
      //send ERR

      vl_PDU_SCCP.pduerror.messageType:=err;
      vl_PDU_SCCP.pduerror.destLocRef:=pl_PDU_SCCP_ConnectionConfirm.sourceLocRef;
      vl_PDU_SCCP.pduerror.errorCause:=cg_Err_unassignedDestinationLRN;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Error
    }//endelse

  }//processing_PDU_SCCP_ConnectionConfirm

  //******************************************************************
  //  processing_PDU_SCCP_Released
  //******************************************************************
  function processing_PDU_SCCP_Released( in PDU_SCCP_Released pl_PDU_SCCP_Released)
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;
    var ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;

    //Store data parameter
    var template SCCP_PAR_UserData tl_data := omit;
    if (ispresent(pl_PDU_SCCP_Released.optionalPart))
    {
      if (ispresent(pl_PDU_SCCP_Released.optionalPart.data))
      {
         tl_data := pl_PDU_SCCP_Released.optionalPart.data.data;
      }
    }

    //check if connection already established
    if (ConnectionAlreadyEstablished(pl_PDU_SCCP_Released.destLocRef))
    {//startif1
      v_session :=Retrieve_session(pl_PDU_SCCP_Released.destLocRef);
      //check if remote reference is correct -Table B.2 /Q.714
      if (ConnectionTable[v_session].remoteReference==pl_PDU_SCCP_Released.sourceLocRef)
      {//startif2
        //Action Table follows
        if (ConnectionTable[v_session].state==idle)//C.3- 1/6  ????nem valoszinu hogy ez eloallhat
        {//startif3

          //assemble and route MTP3_ASP
          vl_PDU_SCCP.relcomp.messageType:=rlc;
          vl_PDU_SCCP.relcomp.destLocRef:=ConnectionTable[v_session].remoteReference;
          vl_PDU_SCCP.relcomp.sourceLocRef:=ConnectionTable[v_session].localReference;

          MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
            (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Release complete
            //then return to idle
        }//endif3
        else if (ConnectionTable[v_session].state==connection_pending_IC)
        { log("RLSD received in state:connection_pending_IC");}//discard message, return
        else if (ConnectionTable[v_session].state==disconnect_pending)
        { log("RLSD received in state:disconnect_pending");}//discard message, return
        else if (ConnectionTable[v_session].state==active)
        {//startif3
          //assemble ASP_SCCP_N_
          vl_N_DISCONNECT_ind.originator:=cg_Mapping_RelCause_Orig[pl_PDU_SCCP_Released.releaseCause];
          vl_N_DISCONNECT_ind.reason:=cg_Mapping_RelCause_Reason[pl_PDU_SCCP_Released.releaseCause];
          vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;

          SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            tl_data,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind
          //assemble and route MTP3_ASP

          vl_PDU_SCCP.relcomp.messageType :=rlc;
          vl_PDU_SCCP.relcomp.destLocRef  :=pl_PDU_SCCP_Released.sourceLocRef;
          vl_PDU_SCCP.relcomp.sourceLocRef:=pl_PDU_SCCP_Released.destLocRef;

          MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
            (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Release complete

          //release resources
          ReleaseResources(v_session);
        }//endif3
        else if (ConnectionTable[v_session].state==connection_pending_OG)
        {//startif3
          //assemble and route MTP3_ASP
          vl_PDU_SCCP.relcomp.messageType :=rlc;
          vl_PDU_SCCP.relcomp.destLocRef  :=pl_PDU_SCCP_Released.sourceLocRef;
          vl_PDU_SCCP.relcomp.sourceLocRef:=pl_PDU_SCCP_Released.destLocRef;
          MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
            (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Release complete

          //stop connection timer
          f_StopTimer(conn_est,v_session);
          //assemble ASP_SCCP_N_

          vl_N_DISCONNECT_ind.originator  :=cg_Mapping_RelCause_Orig[pl_PDU_SCCP_Released.releaseCause];
          vl_N_DISCONNECT_ind.reason      :=cg_Mapping_RelCause_Reason[pl_PDU_SCCP_Released.releaseCause];
          vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;

          SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            tl_data,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind
           //release resources
           ReleaseResources(v_session);

        }//endif3
        else if (ConnectionTable[v_session].state==wait_conn_confirm)
        {//startif3
          //assemble and route MTP3_ASP
          vl_PDU_SCCP.relcomp.messageType  :=rlc;
          vl_PDU_SCCP.relcomp.destLocRef   :=pl_PDU_SCCP_Released.sourceLocRef;
          vl_PDU_SCCP.relcomp.sourceLocRef :=pl_PDU_SCCP_Released.destLocRef;
          MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
            (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Release complete
          //stop connection timer
          f_StopTimer(conn_est,v_session);
          //release resources
          ReleaseResources(v_session);
        }//endif3
        else if (ConnectionTable[v_session].state==reset_IC)
        {//startif3
          //assemble ASP_SCCP_N_
          vl_N_DISCONNECT_ind.originator:=cg_Mapping_RelCause_Orig[pl_PDU_SCCP_Released.releaseCause];
          vl_N_DISCONNECT_ind.reason  :=cg_Mapping_RelCause_Reason[pl_PDU_SCCP_Released.releaseCause];
          vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;
          SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            tl_data,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind

          //release resources, stop inactivity timers, change state to idle
          ReleaseResources(v_session);
        }//endif3
        else if (ConnectionTable[v_session].state==reset_bothway)
        {//startif3
          //assemble ASP_SCCP_N_

          vl_N_DISCONNECT_ind.originator:=cg_Mapping_RelCause_Orig[pl_PDU_SCCP_Released.releaseCause];
          vl_N_DISCONNECT_ind.reason :=cg_Mapping_RelCause_Reason[pl_PDU_SCCP_Released.releaseCause];
          vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;

          SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            tl_data,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind

          //release resources, stop inactivity timers, change state to idle
          ReleaseResources(v_session);

        }//endif3
        else { log("RLSD received in an unexpected state");  }
      }//endif2
      else {//remote reference inconsistent, error action follows

        vl_PDU_SCCP.pduerror.messageType:=err;
        vl_PDU_SCCP.pduerror.destLocRef :=pl_PDU_SCCP_Released.sourceLocRef;
        vl_PDU_SCCP.pduerror.errorCause :=cg_Err_inconsistentSourceLRN;

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Error
      }//endelse
    }//endif1
    else   {//Released(Y,X) received with destLocRef  not in ConnectionTable
    //send RLC(X,Y)

      vl_PDU_SCCP.relcomp.messageType :=rlc;
      vl_PDU_SCCP.relcomp.destLocRef  :=pl_PDU_SCCP_Released.sourceLocRef;
      vl_PDU_SCCP.relcomp.sourceLocRef:=pl_PDU_SCCP_Released.destLocRef;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Release complete

    }//endelse
  }//processing_PDU_SCCP_Released

  //******************************************************************
  //  processing_PDU_SCCP_ProtDataUnitError
  //******************************************************************
  function processing_PDU_SCCP_ProtDataUnitError( in PDU_SCCP_ProtDataUnitError pl_PDU_SCCP_ProtDataUnitError)
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;
    var ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;

    //check if connection already established
    if (ConnectionAlreadyEstablished(pl_PDU_SCCP_ProtDataUnitError.destLocRef))
    {//startif2
      v_session :=Retrieve_session(pl_PDU_SCCP_ProtDataUnitError.destLocRef);
      //Action Table follows

      if (ConnectionTable[v_session].state==idle)
      {//startif3
        //assemble and route MTP3_ASP

        vl_PDU_SCCP.pduerror.messageType:=err;
        vl_PDU_SCCP.pduerror.destLocRef:=ConnectionTable[v_session].remoteReference;
        vl_PDU_SCCP.pduerror.errorCause:=cg_Err_unassignedDestinationLRN;
        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Error
         //then return to idle

      }//endif3
      else if (ConnectionTable[v_session].state==disconnect_pending)
      { log("PDUError received in state:disconnect_pending ");}//discard message, return
      else if (ConnectionTable[v_session].state==connection_pending_IC)
      { log("PDUError received in state:connection_pending_IC ");}//discard message, return
      else if (ConnectionTable[v_session].state==reset_bothway)
      {//startif3
        //assemble ASP_SCCP_N_
        vl_N_DISCONNECT_ind.originator  :=cg_Undefined;
        vl_N_DISCONNECT_ind.reason      :=pl_PDU_SCCP_ProtDataUnitError.errorCause;//?
        vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;
        SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            omit,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind

          //release resources, stop inactivity timers, change state to idle
          ReleaseResources(v_session);
      }//endif3
      else if (ConnectionTable[v_session].state==active)
      {//startif3
        if (pl_PDU_SCCP_ProtDataUnitError.errorCause!=cg_Err_serviceClassMismatch)
        {//startif4

          //assemble ASP_SCCP_N_
          vl_N_DISCONNECT_ind.originator:=cg_Undefined;
          vl_N_DISCONNECT_ind.reason:=pl_PDU_SCCP_ProtDataUnitError.errorCause;//?
          vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;

          SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            omit,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind
          //release resources
          ReleaseResources(v_session);

        }//endif4
        else {//startelse -Service class mismatch

          //assemble ASP_SCCP_N_

          vl_N_DISCONNECT_ind.originator  :=cg_Undefined;
          vl_N_DISCONNECT_ind.reason      :=pl_PDU_SCCP_ProtDataUnitError.errorCause;
          vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;

          SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
          vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            omit,
            vl_N_DISCONNECT_ind.connectionId,
            omit
              ));//send ASP_SCCP_N_DISCONNECT_ind

           //stop inactivity timers
          f_StopTimer(iar,v_session);
          f_StopTimer(ias,v_session);
          //send Released
          //assemble and route MTP3_ASP

          vl_PDU_SCCP.released.messageType:=rlsd;
          vl_PDU_SCCP.released.destLocRef:=ConnectionTable[v_session].remoteReference;
          vl_PDU_SCCP.released.sourceLocRef:=ConnectionTable[v_session].localReference;
          vl_PDU_SCCP.released.releaseCause:=cg_Rel_inconsConnData;
          vl_PDU_SCCP.released.pointer1:=0;//No optional part
          vl_PDU_SCCP.released.optionalPart:=omit;
          vl_PDU_SCCP.released.eop:=omit;

          MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
            (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Released

          //start release timer
          f_StartTimer(rel,v_session);
          //change state to diconnect pending
          ConnectionTable[v_session].state:=disconnect_pending;

        }//endelse

      }//endif3
      else if (ConnectionTable[v_session].state==connection_pending_OG)
      {//startif3
        //stop connection timer
        f_StopTimer(conn_est,v_session);
        //assemble ASP_SCCP_N_

        vl_N_DISCONNECT_ind.originator  :=cg_Undefined;
        vl_N_DISCONNECT_ind.reason      :=pl_PDU_SCCP_ProtDataUnitError.errorCause;
        vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;

        SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
          vl_N_DISCONNECT_ind.originator,
          omit,
          vl_N_DISCONNECT_ind.reason,
          omit,
          vl_N_DISCONNECT_ind.connectionId,
          omit
        ));//send ASP_SCCP_N_DISCONNECT_ind
        //release resources
        ReleaseResources(v_session);
      }//endif3
      else if (ConnectionTable[v_session].state==wait_conn_confirm)
      {//startif3

        //stop connection timer
        f_StopTimer(conn_est,v_session);
        //release resources
        ReleaseResources(v_session);


      }//endif3
      else if (ConnectionTable[v_session].state==reset_IC)
      {//startif3
        //assemble ASP_SCCP_N_
        vl_N_DISCONNECT_ind.originator:=cg_Undefined;
        vl_N_DISCONNECT_ind.reason:=pl_PDU_SCCP_ProtDataUnitError.errorCause;
        vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;
        SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            omit,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind

        //release resources, stop inactivity timers, change state to idle
        ReleaseResources(v_session);

      }//endif3
      else { log("PDUError received in an unexpected state");  }
    }//endif2
    else {}//PDU_Error received with destLocRef  not in ConnectionTable

  }//processing_PDU_SCCP_ProtDataUnitError

  //******************************************************************
  //  processing_PDU_SCCP_ReleaseComplete
  //******************************************************************
  function processing_PDU_SCCP_ReleaseComplete(in PDU_SCCP_ReleaseComplete pl_PDU_SCCP_ReleaseComplete)
  runs on SCCP_CT
  {
    var ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;

    //check if connection already established
    if (ConnectionAlreadyEstablished(pl_PDU_SCCP_ReleaseComplete.destLocRef))
    {//startif1

      v_session :=Retrieve_session(pl_PDU_SCCP_ReleaseComplete.destLocRef);
      //check if remote reference is correct -Table B.2 /Q.714
      if (ConnectionTable[v_session].remoteReference==pl_PDU_SCCP_ReleaseComplete.sourceLocRef)
      {//startif2

        //Action Table follows
        if (ConnectionTable[v_session].state==idle)
        { log("RLC received in state: idle"); }//C.3 1/6-do nothing-return to idle state
        else if (ConnectionTable[v_session].state==connection_pending_IC)
        { log("RLC received in state: connection_pending_IC"); }//discard message, return
        else if (ConnectionTable[v_session].state==active)
        { log("RLC received in state: active"); }//do nothing, return
        else if (ConnectionTable[v_session].state==reset_bothway)
        { log("RLC received in state:reset_bothway "); }//
        else if (ConnectionTable[v_session].state==disconnect_pending)
        {//startif3
          log("RLC received in state:disconnect_pending ");
          //log("release resources");
          ReleaseResources(v_session);
        }//endif3
        else if (ConnectionTable[v_session].state==connection_pending_OG)
        {//startif3
          f_StopTimer(conn_est,v_session);
          //assemble ASP_SCCP_N_
          vl_N_DISCONNECT_ind.originator:=cg_NSU;
          vl_N_DISCONNECT_ind.reason:=cg_DISC_normal;
          vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;

          SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            omit,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind
          //release resources
          ReleaseResources(v_session);
        }//endif3
        else if (ConnectionTable[v_session].state==wait_conn_confirm)
        {//startif3
          log("RLC received in state:wait_conn_confirm");
          //stop connection timer
          f_StopTimer(conn_est,v_session);
          //release resources
          ReleaseResources(v_session);
        }//endif3
        else if (ConnectionTable[v_session].state==reset_IC)
        {//startif3
          log("RLC received in state:reset_IC");
          //discard received message
          f_StartTimer(internal_reset,v_session,0.0);//the timer times out immediately
          //state changed to active
          ConnectionTable[v_session].state:=active;
        }//endif3
        else { log("RLC received in an unexpected state");  }

      }//endif2
      else {}//remote reference inconsistent, discard

    }//endif1
    else {}//Release complete received with destLocRef  not in ConnectionTable
    //discard

  }//processing_PDU_SCCP_ReleaseComplete

  //******************************************************************
  //  processing_PDU_SCCP_InactivityTest
  //******************************************************************
  function processing_PDU_SCCP_InactivityTest( in PDU_SCCP_InactivityTest pl_PDU_SCCP_InactivityTest)
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;
    var ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;

    //check if connection already established
    if (ConnectionAlreadyEstablished(pl_PDU_SCCP_InactivityTest.destLocRef))
    {//startif1
      v_session :=Retrieve_session(pl_PDU_SCCP_InactivityTest.destLocRef);

      //check if remote reference is correct -Table B.2 /Q.714
      if (ConnectionTable[v_session].remoteReference==pl_PDU_SCCP_InactivityTest.sourceLocRef)
      {//startif2

        //Action Table follows
        if (ConnectionTable[v_session].state==idle)
        { log("IT received in state :idle "); }//C.3 1/6-do nothing-return to idle state
        else if (ConnectionTable[v_session].state==connection_pending_IC)
        { log("IT received in state : connection_pending_IC"); }//discard message, return
        else if (ConnectionTable[v_session].state==connection_pending_OG)
        {//startif3

          //stop connection timer
          f_StopTimer(conn_est,v_session);
          //assemble ASP_SCCP_N_
          vl_N_DISCONNECT_ind.originator    := cg_NSU;
          vl_N_DISCONNECT_ind.reason        := cg_DISC_normal;
          vl_N_DISCONNECT_ind.connectionId  := ConnectionTable[v_session].connectionId;

          SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            omit,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind
          //release resources
          ReleaseResources(v_session);

        }//endif3
        else if (ConnectionTable[v_session].state==disconnect_pending) {}
        else if (ConnectionTable[v_session].state==reset_bothway) {}//
        else if (ConnectionTable[v_session].state==active)
        {//startif3
           //source reference number assumed OK
          //or:
          //if (ConnectionTable[v_session].remoteReference!=pl_PDU_SCCP_InactivityTest.sourceLocRef)
          // release connection
          //protocol class assumed 2
          //restart receive inactivity timer
          f_StopTimer(iar,v_session);//to avoid warnings
          f_StartTimer(iar,v_session);
        }//endif3
        else if (ConnectionTable[v_session].state==reset_IC)
        {//startif3
          //discard received message
          f_StartTimer(internal_reset,v_session,0.0);//the timer times out immediately
          //state changed to active
          ConnectionTable[v_session].state:=active;
        }//endif3
        else if (ConnectionTable[v_session].state==wait_conn_confirm)
        {//startif3

          //stop connection timer
          f_StopTimer(conn_est,v_session);
          //release resources
          ReleaseResources(v_session);

        }//endif3
        else { log("IT received in an unexpected state");  }
      }//endif2
      else {//remote reference inconsistent, error action follows
            //message received with remote reference not the same as stored
            // two RLSD messages are sent back, one to the sored and to the received remote reference
            //sent first RLSD-see B.2/Q.714

        vl_PDU_SCCP.released.messageType :=rlsd;
        vl_PDU_SCCP.released.destLocRef  :=pl_PDU_SCCP_InactivityTest.sourceLocRef;
        vl_PDU_SCCP.released.sourceLocRef:=pl_PDU_SCCP_InactivityTest.destLocRef;
        vl_PDU_SCCP.released.releaseCause:=cg_Rel_inconsConnData;
        vl_PDU_SCCP.released.pointer1:=0;
        vl_PDU_SCCP.released.optionalPart:=omit;
        vl_PDU_SCCP.released.eop:=omit;

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Released

        //sent second  RLSD-see B.2/Q.714
        vl_PDU_SCCP.released.destLocRef :=ConnectionTable[v_session].remoteReference;

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Released

      }//endelse

    }//endif1
    else {}//Inactivity test received with destLocRef  not in ConnectionTable
    //discard

  }//processing_PDU_SCCP_InactivityTest

  //******************************************************************
  //   processing_PDU_SCCP_ResetRequest
  //******************************************************************
  function processing_PDU_SCCP_ResetRequest ( in PDU_SCCP_ResetRequest pl_PDU_SCCP_ResetRequest)
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;

    //check if connection already established
    if (ConnectionAlreadyEstablished(pl_PDU_SCCP_ResetRequest.destLocRef))
    {//startif1
      v_session :=Retrieve_session(pl_PDU_SCCP_ResetRequest.destLocRef);
      //check if remote reference is correct -Table B.2 /Q.714

      if (ConnectionTable[v_session].remoteReference==pl_PDU_SCCP_ResetRequest.sourceLocRef)
      {//startif2
        //Action Table follows
        if (ConnectionTable[v_session].state==idle)
        {//startif3

          //assemble and route MTP3_ASP
          vl_PDU_SCCP.pduerror.messageType:=err;
          vl_PDU_SCCP.pduerror.destLocRef:=ConnectionTable[v_session].remoteReference;
          vl_PDU_SCCP.pduerror.errorCause:=cg_Err_unassignedDestinationLRN;
          MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
            (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Error
          //then return to idle

        }//endif3
        else if (ConnectionTable[v_session].state==connection_pending_IC) {}//discard message, return
        else if (ConnectionTable[v_session].state==connection_pending_OG)
        {//startif3
          //stop connection timer
          f_StopTimer(conn_est,v_session);
          //assemble ASP_SCCP_N_
          var ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;
          vl_N_DISCONNECT_ind.originator:=cg_NSU;
          vl_N_DISCONNECT_ind.reason:=cg_DISC_normal;
          vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;
          SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            omit,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind
          //release resources
          ReleaseResources(v_session);
        }//endif3
        else if (ConnectionTable[v_session].state==disconnect_pending) {}
        else if (ConnectionTable[v_session].state==reset_bothway)
        {//startif3

          //assemble ASP_SCCP_N_
          var ASP_SCCP_N_RESET_cfm vl_N_RESET_cfm;
          vl_N_RESET_cfm.connectionId:=ConnectionTable[v_session].connectionId;
          SCCP_SP_PORT.send( t_ASP_N_RESET_cfm(vl_N_RESET_cfm.connectionId));//send ASP_SCCP_N_RESET_cfm

          //stop reset timer
          f_StopTimer(reset,v_session);

          //restart receive inactivity timer
          f_StopTimer(iar,v_session);//to avoid warnings
          f_StartTimer(iar,v_session);
          //change state
          ConnectionTable[v_session].state:=reset_IC;
        }//endif3
        else if (ConnectionTable[v_session].state==active)
        {//startif3
          //restart receive inactivity timer
          f_StopTimer(iar,v_session);//to avoid warnings
          f_StartTimer(iar,v_session);
          //send ASP_SCCP_N_RESET_ind
          //assemble ASP_SCCP_N_
          var ASP_SCCP_N_RESET_ind vl_N_RESET_ind;
          vl_N_RESET_ind.originator:=cg_NSU;
          vl_N_RESET_ind.reason:=cg_RESET_unspec;
          vl_N_RESET_ind.connectionId:=ConnectionTable[v_session].connectionId;

          SCCP_SP_PORT.send( t_ASP_N_RESET_ind(
            vl_N_RESET_ind.originator,
            vl_N_RESET_ind.reason,
            vl_N_RESET_ind.connectionId
            ));//send ASP_SCCP_N_RESET_ind

          //reset variables
          ConnectionTable[v_session].state:=reset_IC;
        }//endif3
        else if (ConnectionTable[v_session].state==wait_conn_confirm)
        {//startif3

          //stop connection timer
          f_StopTimer(conn_est,v_session);
          //release resources
          ReleaseResources(v_session);
        }//endif3
        else { log("RESREQ received in an unexpected state");  }
      }//endif2
      else {//remote reference inconsistent, error action follows

        vl_PDU_SCCP.pduerror.messageType:=err;
        vl_PDU_SCCP.pduerror.destLocRef:=pl_PDU_SCCP_ResetRequest.sourceLocRef;
        vl_PDU_SCCP.pduerror.errorCause:=cg_Err_inconsistentSourceLRN;
        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Error

      }//endelse
    }//endif1
    else     {//startelse-Reset request received with destLocRef  not in ConnectionTable

      //send ERR
      vl_PDU_SCCP.pduerror.messageType:=err;
      vl_PDU_SCCP.pduerror.destLocRef:=pl_PDU_SCCP_ResetRequest.sourceLocRef;
      vl_PDU_SCCP.pduerror.errorCause:=cg_Err_unassignedDestinationLRN;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
      (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Error

    }//endelse

  }//processing_PDU_SCCP_ResetRequest

  //******************************************************************
  //   processing_PDU_SCCP_ResetConfirm
  //******************************************************************
  function processing_PDU_SCCP_ResetConfirm ( in PDU_SCCP_ResetConfirm pl_PDU_SCCP_ResetConfirm)
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;

    //check if connection already established
    if (ConnectionAlreadyEstablished(pl_PDU_SCCP_ResetConfirm.destLocRef))
    {//startif1
      v_session :=Retrieve_session(pl_PDU_SCCP_ResetConfirm.destLocRef);

      //check if remote reference is correct -Table B.2 /Q.714
      if (ConnectionTable[v_session].remoteReference==pl_PDU_SCCP_ResetConfirm.sourceLocRef)
      {//startif2
        //Action Table follows

        if (ConnectionTable[v_session].state==idle)
        { log("RSC received in state:idle ");}//do nothing-return to idle state, no source ref known
        else if (ConnectionTable[v_session].state==connection_pending_IC)
        { log("RSC received in state:connection_pending_IC ");}//discard message, return
        else if (ConnectionTable[v_session].state==connection_pending_OG)
        {//startif3

          var ASP_SCCP_N_DISCONNECT_ind vl_N_DISCONNECT_ind;
          //stop connection timer
          f_StopTimer(conn_est,v_session);
          //assemble ASP_SCCP_N_ASP

          vl_N_DISCONNECT_ind.originator:=cg_NSU;
          vl_N_DISCONNECT_ind.reason:=cg_DISC_normal;
          vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;
          SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            omit,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind
          //release resources
          ReleaseResources(v_session);
        }//endif3
        else if (ConnectionTable[v_session].state==disconnect_pending)
        { log("RSC received in state:disconnect_pending");}
        else if (ConnectionTable[v_session].state==reset_bothway)
        {//startif3
          //assemble ASP_SCCP_N_
          var ASP_SCCP_N_RESET_cfm vl_N_RESET_cfm;
          vl_N_RESET_cfm.connectionId:=ConnectionTable[v_session].connectionId;
          SCCP_SP_PORT.send( t_ASP_N_RESET_cfm(
            vl_N_RESET_cfm.connectionId
            ));//send ASP_SCCP_N_RESET_cfm

          //stop reset timer
          f_StopTimer(reset,v_session);

          //restart receive inactivity timer
          f_StopTimer(iar,v_session);//to avoid warnings
          f_StartTimer(iar,v_session);
          //change state
          ConnectionTable[v_session].state:=reset_IC;
        }//endif3
        else if (ConnectionTable[v_session].state==active)
        {//startif3
          //do nothing-return to idle state
          log("RSC received in state:active");
        }//endif3
        else if (ConnectionTable[v_session].state==reset_IC)
        {//startif3
          //discard received message
          f_StartTimer(internal_reset,v_session,0.0);//the timer times out immediately
          //state changed to active
          ConnectionTable[v_session].state:=active;
        }//endif3
        else if (ConnectionTable[v_session].state==wait_conn_confirm)
        {//startif3
          //stop connection timer
          f_StopTimer(conn_est,v_session);
          //release resources
          ReleaseResources(v_session);
       }//endif3
       else { log("ResConf received in an unexpected state");  }
      }//endif2
      else {//remote reference inconsistent, error action follows

        vl_PDU_SCCP.pduerror.messageType:=err;
        vl_PDU_SCCP.pduerror.destLocRef :=pl_PDU_SCCP_ResetConfirm.sourceLocRef;
        vl_PDU_SCCP.pduerror.errorCause :=cg_Err_inconsistentSourceLRN;

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Error

      }//endelse
    }//endif1
    else       {//startelse-Reset confirm received with destLocRef  not in ConnectionTable

      //send ERR
      vl_PDU_SCCP.pduerror.messageType:=err;
      vl_PDU_SCCP.pduerror.destLocRef :=pl_PDU_SCCP_ResetConfirm.sourceLocRef;
      vl_PDU_SCCP.pduerror.errorCause :=cg_Err_unassignedDestinationLRN;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Error
    }//endelse
  }//processing_PDU_SCCP_ResetConfirm

  //******************************************************************
  //   processing_PDU_SCCP_ConnectionRefused
  //******************************************************************
  function processing_PDU_SCCP_ConnectionRefused ( in PDU_SCCP_ConnectionRefused pl_PDU_SCCP_ConnectionRefused)
  runs on SCCP_CT
  {
    //Store data parameter
    var template SCCP_PAR_UserData tl_data := omit;
    if (ispresent(pl_PDU_SCCP_ConnectionRefused.optionalPart))
    {
      if (ispresent(pl_PDU_SCCP_ConnectionRefused.optionalPart.data))
      {
         tl_data := pl_PDU_SCCP_ConnectionRefused.optionalPart.data.data;
      }
    }

    //check if connection already established
    if (ConnectionAlreadyEstablished(pl_PDU_SCCP_ConnectionRefused.destLocRef))
    {//startif2
      v_session :=Retrieve_session(pl_PDU_SCCP_ConnectionRefused.destLocRef);
      //Action Table follows

      if (ConnectionTable[v_session].state==idle)
      { log ("CREF received in state:idle");} //do nothing , return to idle, source ref unknown
      else if (ConnectionTable[v_session].state==connection_pending_IC)
      { log ("CREF received in state:connection_pending_IC");}
      else if (ConnectionTable[v_session].state==active)
      { log ("CREF received in state:active");}//do nothing, return
      else if (ConnectionTable[v_session].state==disconnect_pending)
      { log ("CREF received in state:disconnect_pending");}//discard message, return
      else if (ConnectionTable[v_session].state==reset_bothway)
      { log ("CREF received in state:reset_bothway");}//
      else if (ConnectionTable[v_session].state==connection_pending_OG)
      {//startif3
        var ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;
        //stop connection timer
        f_StopTimer(conn_est,v_session);
        //assemble ASP_SCCP_N_
        vl_N_DISCONNECT_ind.originator:=cg_Mapping_RefCause_Orig[pl_PDU_SCCP_ConnectionRefused.refusalCause];
        vl_N_DISCONNECT_ind.reason:=cg_Mapping_RefCause_Reason[pl_PDU_SCCP_ConnectionRefused.refusalCause];
        vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;

        SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            tl_data,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind
        //release resources
        ReleaseResources(v_session);
      }//endif3
      else if (ConnectionTable[v_session].state==wait_conn_confirm)
      {//startif3

        //stop connection timer
        f_StopTimer(conn_est,v_session);
        //release resources
        ReleaseResources(v_session);

      }//endif3
      else if (ConnectionTable[v_session].state==reset_IC)
      {//startif3

        //discard received message
        f_StartTimer(internal_reset,v_session,0.0);//the timer times out immediately
        //state changed to active
        ConnectionTable[v_session].state:=active;

      }//endif3
      else { log("CREF received in an unexpected state");  }

    }//endif2
    else { log("CREF received with destLocRef not in state table");  }
    //Connection refused with destLocRef  not in ConnectionTable
    //discard

  } //processing_PDU_SCCP_ConnectionRefused

  //******************************************************************
  //   processing_PDU_SCCP_DataForm1
  //******************************************************************
  function processing_PDU_SCCP_DataForm1 ( in PDU_SCCP_DataForm1 pl_PDU_SCCP_DataForm1)
  runs on SCCP_CT
  {

    //check if connection already established
    if (ConnectionAlreadyEstablished(pl_PDU_SCCP_DataForm1.destLocRef))
    {//startif2
      v_session :=Retrieve_session(pl_PDU_SCCP_DataForm1.destLocRef);
      //Action Table follows

      if (ConnectionTable[v_session].state==idle)
      {//startif3
        var PDU_SCCP vl_PDU_SCCP;
        //assemble and route MTP3_ASP
        vl_PDU_SCCP.pduerror.messageType:=err;
        vl_PDU_SCCP.pduerror.destLocRef:=ConnectionTable[v_session].remoteReference;
        vl_PDU_SCCP.pduerror.errorCause:=cg_Err_unassignedDestinationLRN;

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //Send Error

          //then return to idle
      }//endif3
      else if (ConnectionTable[v_session].state==connection_pending_IC)
      { log ("DT1 received in state:connection_pending_IC");}//discard message, return
      else if (ConnectionTable[v_session].state==disconnect_pending)
      { log ("DT1 received in state:disconnect_pending");}//discard message, return
      else if (ConnectionTable[v_session].state==reset_bothway)
      { log ("DT1 received in state:reset_bothway");}//
      else if (ConnectionTable[v_session].state==connection_pending_OG)
      {//startif3
        var ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;
        f_StopTimer(conn_est,v_session);
        //assemble ASP_SCCP_N_
        vl_N_DISCONNECT_ind.originator:=cg_NSU;
        vl_N_DISCONNECT_ind.reason:=cg_DISC_normal;
        vl_N_DISCONNECT_ind.connectionId:=ConnectionTable[v_session].connectionId;

        SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            omit,
            vl_N_DISCONNECT_ind.connectionId,
            omit
            ));//send ASP_SCCP_N_DISCONNECT_ind
        //release resources
        ReleaseResources(v_session);
      }//endif3
      else if (ConnectionTable[v_session].state==wait_conn_confirm)
      {//startif3

        //stop connection timer
        f_StopTimer(conn_est,v_session);
        //release resources
        ReleaseResources(v_session);
      }//endif3
      else if (ConnectionTable[v_session].state==active)
      {//startif3

        var ASP_SCCP_N_DATA_ind vl_N_DATA_ind;
        //restart receive inactivity  timer
        f_StopTimer(iar,v_session);//to avoid warnings
        f_StartTimer(iar,v_session);

        buffered_sending_ASP_N_DATA_ind( pl_PDU_SCCP_DataForm1 )
        //MODIFY-> protocol class assumed 2; M bit assumed 0 (no segm/reassembly)

      }//endif3
      else if (ConnectionTable[v_session].state==reset_IC)
      {//startif3

        //discard received message
        f_StartTimer(internal_reset,v_session,0.0);//the timer times out immediately
        //state changed to active
        ConnectionTable[v_session].state:=active;

      }//endif3
      else { log("DT1 received in an unexpected state");  }

    }//endif2
    else { log("DT1 received with destLocRef  not in ConnectionTable"); }
      //DT1 received with destLocRef  not in ConnectionTable
      //discard

  }//processing_PDU_SCCP_DataForm1


  //******************************************************************
  //   processing_PDU_SCCP_ExtUnitdata
  //******************************************************************
  function processing_PDU_SCCP_ExtUnitdata ( in PDU_SCCP_ExtUnitdata pl_PDU_SCCP_ExtUnitdata)
  runs on SCCP_CT
  {
    var   integer               vl_index;
    var   OCT3                  vl_segmRemoteRef;
    if( ispresent( pl_PDU_SCCP_ExtUnitdata.optionalPart) and
        ispresent( pl_PDU_SCCP_ExtUnitdata.optionalPart.segmentation) )
    {
      vl_segmRemoteRef:= pl_PDU_SCCP_ExtUnitdata.optionalPart.segmentation.segmLocalRef;
      if( pl_PDU_SCCP_ExtUnitdata.optionalPart.segmentation.firstSegm =='1'B )
      {
         vl_index:=allocate_ClessRcvBuff( vl_segmRemoteRef);
      }
      else
      {
        vl_index:=get_ClessRcvBuffIndex( vl_segmRemoteRef );
      };
      if (vl_index == -1) 
      { 
        log("Buffer allocation failed, message ignored.");
        return; 
      }
        
      store_segmData(vl_index,pl_PDU_SCCP_ExtUnitdata);
      if( pl_PDU_SCCP_ExtUnitdata.optionalPart.segmentation.remainingSegment == '0000'B )
      {
        send_ClessRcvBuff_in_N_UNITDATAind( vl_index,pl_PDU_SCCP_ExtUnitdata );
        reallocate_ClessRcvBuff( vl_index );
      }
    }
    else
    { // not segmented case:
      send_ClessData_in_N_UNITDATAind( pl_PDU_SCCP_ExtUnitdata );
    }
    return;

  }//processing_PDU_SCCP_ExtUnitdata

//******************************************************************
//  Part 2  Receiving msg on port "SCCP_PORT" (User Part)
//******************************************************************

//******************************************************************
//  processing_ASP_N_CONNECT_req
// / ASP_SCCP_N_CONNECT_req ,   originating  node /
//******************************************************************
  function processing_ASP_N_CONNECT_req( in ASP_SCCP_N_CONNECT_req pl_N_CONNECT_req )
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;
    var        ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;

    if (ConnectionAlreadyEstablished_connectionId(pl_N_CONNECT_req.connectionId))
    // assume connectionId present
    {//startif1

      //something went wrong, we already have a session with the same connection Id
      v_session :=Retrieve_session_connectionId(pl_N_CONNECT_req.connectionId);
      //table of error actions

    }//endif1
    else
    {//startelse1

      //check if resources available
      v_session:=CheckIdleIndividuals();
      if (v_session==-1)     //No idle individual found
      {//startif2

        //assemble ASP_SCCP_N_ASP
        vl_N_DISCONNECT_ind.originator:=cg_NSP; // network service provider
        vl_N_DISCONNECT_ind.reason:=cg_CREF_unspec_T;
        vl_N_DISCONNECT_ind.connectionId:=pl_N_CONNECT_req.connectionId;

        SCCP_SP_PORT.send( t_ASP_N_DISCONNECT_ind(
            vl_N_DISCONNECT_ind.originator,
            omit,
            vl_N_DISCONNECT_ind.reason,
            omit,
            vl_N_DISCONNECT_ind.connectionId,
            omit
        ));//send ASP_SCCP_N_DISCONNECT_ind
        //return to idle
      }//endif2

      if ((v_session<=15)and (v_session>=0))
      {//startif2

        //assign local reference, SLS:=tsp_MTP3_SLS, protocol class:=2
        ConnectionTable[v_session].localReference:=int2oct(pl_N_CONNECT_req.connectionId,3);
        ConnectionTable[v_session].connectionId  :=pl_N_CONNECT_req.connectionId;

        //to simplify generation of local reference, connectionID received from user is sent as such
        //only local reference is assigned at this point
        //send connection request, no coupling
        //DPC :remote  node
        //no coupling reqrd.
        //compatibility OK
        //no restriction
        //assemble and route MTP3_ASP
        vl_PDU_SCCP.connrequest.messageType:=cr;
        vl_PDU_SCCP.connrequest.sourceLocRef:=ConnectionTable[v_session].localReference;
        // send local reference just assigned!
        vl_PDU_SCCP.connrequest.protClass:={
          class:='0010'B,
          messageHandling:='0000'B
          };//class 2
        vl_PDU_SCCP.connrequest.pointer1:=2;
        vl_PDU_SCCP.connrequest.calledPAddress:=ConvertASPAddressToEncodedAddress(pl_N_CONNECT_req.calledAddress); //new!
        vl_PDU_SCCP.connrequest.pointer2:=vl_PDU_SCCP.connrequest.calledPAddress.paramLength+2; //automatic?

        if(ispresent(pl_N_CONNECT_req.callingAddress))
        {//startif3

          //temporary variable  to avoid type conversion problems
          var SCCP_param_CPartyAddressEnc_opt   vl_SCCP_param_CPartyAddressEnc_opt;
          var SCCP_param_CPartyAddressEnc       vl_SCCP_param_CPartyAddressEnc;

          vl_SCCP_param_CPartyAddressEnc:=
            ConvertASPAddressToEncodedAddress(pl_N_CONNECT_req.callingAddress);

          vl_SCCP_param_CPartyAddressEnc_opt.paramName  :=con_SCCP_cgPA;
          vl_SCCP_param_CPartyAddressEnc_opt.paramLength:=vl_SCCP_param_CPartyAddressEnc.paramLength;
          vl_SCCP_param_CPartyAddressEnc_opt.addr       :=vl_SCCP_param_CPartyAddressEnc.addr;

          vl_PDU_SCCP.connrequest.optionalPart.callingPAddress:=vl_SCCP_param_CPartyAddressEnc_opt;

        }//endif3
        else { vl_PDU_SCCP.connrequest.optionalPart.callingPAddress:=omit }

        if(ispresent(pl_N_CONNECT_req.userData))
        {//startif3

            //temporary variable  to avoid type conversion problems
            var SCCP_param_Data_opt  vl_SCCP_param_Data_opt;

            vl_SCCP_param_Data_opt.paramName:=con_SCCP_data;
            vl_SCCP_param_Data_opt.data:=pl_N_CONNECT_req.userData;
            vl_SCCP_param_Data_opt.paramLength:=lengthof(vl_SCCP_param_Data_opt.data);
            vl_PDU_SCCP.connrequest.optionalPart.data:=vl_SCCP_param_Data_opt;

        }//endif3
        else { vl_PDU_SCCP.connrequest.optionalPart.data:=omit}

        if(ispresent(pl_N_CONNECT_req.callingAddress) or
           ispresent(pl_N_CONNECT_req.userData))
        {
          vl_PDU_SCCP.connrequest.optionalPart.credit:=omit;
          vl_PDU_SCCP.connrequest.optionalPart.hopCounter:=omit;
          vl_PDU_SCCP.connrequest.optionalPart.importance:=omit;

          vl_PDU_SCCP.connrequest.eop:= {paramName:=con_SCCP_eop};
        }
        else
        {
          vl_PDU_SCCP.connrequest.optionalPart := omit;
          vl_PDU_SCCP.connrequest.eop := omit;
        }

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Connection request

        //start connection timer
        f_StartTimer(conn_est,v_session);
        ConnectionTable[v_session].state:=connection_pending_OG;
      }//endif2

    }//endelse

  }//processing_ASP_N_CONNECT_req
  //******************************************************************
  //End ASP_SCCP_N_CONNECT_req ,   originating  node
  //******************************************************************

  //******************************************************************
  //  processing_ASP_N_CONNECT_resp
  //******************************************************************
  function processing_ASP_N_CONNECT_res( in ASP_SCCP_N_CONNECT_res pl_N_CONNECT_res )
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;

    // first see if session exists in the ConnectionTable
    //search done based on Connection ID

    if (ConnectionAlreadyEstablished_connectionId(pl_N_CONNECT_res.connectionId))
    //assume connectionId present
    {//startif1
      //retrieve session
      v_session :=Retrieve_session_connectionId(pl_N_CONNECT_res.connectionId);

      //Action Table follows

      if (ConnectionTable[v_session].state==idle)
      {
        log("N_CONNECT_resp received in state:idle");
        //do nothing-return to idle state
      }
      else if (ConnectionTable[v_session].state==connection_pending_IC)
      {//startif2

        //assign SLS:=tsp_MTP3_SLS, assign protocol class=2 (CO, no flow ctrl.)

        //assemble and route MTP3_ASP

        vl_PDU_SCCP.connconfirm.messageType:=cc;
        vl_PDU_SCCP.connconfirm.sourceLocRef:=ConnectionTable[v_session].localReference;
        vl_PDU_SCCP.connconfirm.destLocRef:=ConnectionTable[v_session].remoteReference;
        vl_PDU_SCCP.connconfirm.protClass.class:='0010'B;//protocol class 2
        vl_PDU_SCCP.connconfirm.protClass.messageHandling:='0000'B;//no special treatment

        if(ispresent(pl_N_CONNECT_res.respondingAddress))
        {//startif3

          //temporary variable  to avoid type conversion problems
          var SCCP_param_CPartyAddressEnc_opt vl_SCCP_param_CPartyAddressEnc_opt;
          var SCCP_param_CPartyAddressEnc     vl_SCCP_param_CPartyAddressEnc;

          vl_SCCP_param_CPartyAddressEnc:=
              ConvertASPAddressToEncodedAddress(pl_N_CONNECT_res.respondingAddress);

          vl_SCCP_param_CPartyAddressEnc_opt.paramName  := con_SCCP_cdPA; // cgPA->cdPA  ethbaat, 2003.11.06
          vl_SCCP_param_CPartyAddressEnc_opt.paramLength:= vl_SCCP_param_CPartyAddressEnc.paramLength;
          vl_SCCP_param_CPartyAddressEnc_opt.addr       := vl_SCCP_param_CPartyAddressEnc.addr;

          vl_PDU_SCCP.connconfirm.optionalPart.calledPAddress:= vl_SCCP_param_CPartyAddressEnc_opt;
        }//endif3
        else { vl_PDU_SCCP.connconfirm.optionalPart.calledPAddress:=omit }

        if(ispresent(pl_N_CONNECT_res.userData))
        {//startif3

          //temporary variable  to avoid type conversion problems
          var SCCP_param_Data_opt  vl_SCCP_param_Data_opt;

          vl_SCCP_param_Data_opt.paramName:=con_SCCP_data;
          vl_SCCP_param_Data_opt.data:=pl_N_CONNECT_res.userData; // corrected by ethbaat 2003.10.16
          vl_SCCP_param_Data_opt.paramLength:=lengthof(vl_SCCP_param_Data_opt.data);

          vl_PDU_SCCP.connconfirm.optionalPart.data:=vl_SCCP_param_Data_opt;
        }//endif3
        else {vl_PDU_SCCP.connconfirm.optionalPart.data:=omit}

        if(ispresent(pl_N_CONNECT_res.respondingAddress) or
           ispresent(pl_N_CONNECT_res.userData))
        {
          vl_PDU_SCCP.connconfirm.pointer1:=1;
          vl_PDU_SCCP.connconfirm.optionalPart.credit:=omit;
          vl_PDU_SCCP.connconfirm.optionalPart.importance:=omit;
          vl_PDU_SCCP.connconfirm.eop:= {paramName:=con_SCCP_eop};
        }
        else
        {
          vl_PDU_SCCP.connconfirm.pointer1:=0;
          vl_PDU_SCCP.connconfirm.optionalPart := omit;
          vl_PDU_SCCP.connconfirm.eop:=omit;
        }

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send connection confirm

        f_StartTimer(ias,v_session);  // ??? check them!!!
        f_StartTimer(iar,v_session);  //start inactivity timers
        ConnectionTable[v_session].state:=active;//state change

      }//endif2
      else { log("N_CONNECT_resp received in an unexpected state");}

    }//endif1

  }//processing_ASP_N_CONNECT_resp

  //******************************************************************
  //  processing_ASP_N_DATA_req
  //******************************************************************

  function processing_ASP_N_DATA_req( in ASP_SCCP_N_DATA_req pl_N_DATA_req )
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;

    // first see if session exists in the ConnectionTable

    if (ConnectionAlreadyEstablished_connectionId(pl_N_DATA_req.connectionId))
    //assume connectionId present
    {//startif1

      //retrieve v_session
      v_session :=Retrieve_session_connectionId(pl_N_DATA_req.connectionId);

      //Action Table follows
      if (ConnectionTable[v_session].state==idle)
      { log ("N_DATA_req received in idle state");}
      else if (ConnectionTable[v_session].state==reset_bothway)
      { log ("N_DATA_req received in reset_bothway state");}
      else if (ConnectionTable[v_session].state==active)
      {//startif2
        sending_dataform1s_in_ASP_MTP_TRANSFERreqs(pl_N_DATA_req);
        //no change of state, remains active
      }//endif2
      else { log ("N_DATA_req received in an unexpected state"); }

    }//endif1
    else { log("N_DATA_req with Connection ID not in the state table -- illegal request"); }

  }//processing_ASP_N_DATA_req

  //******************************************************************
  //  processing_ASP_N_DISCONNECT_req
  //******************************************************************

  function processing_ASP_N_DISCONNECT_req( in ASP_SCCP_N_DISCONNECT_req pl_N_DISCONNECT_req )
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;
    var boolean vl_opt_part_present:=false;

    // first see if session exists in the ConnectionTable

    if (ConnectionAlreadyEstablished_connectionId(pl_N_DISCONNECT_req.connectionId))
    //assume connectionId present
    {//startif1

      //retrieve v_session
      v_session :=Retrieve_session_connectionId(pl_N_DISCONNECT_req.connectionId);

      //Action Table follows
      if (ConnectionTable[v_session].state==idle)
      { log ("N_DISCONNECT_req received in state:idle");}
      else if (ConnectionTable[v_session].state==connection_pending_IC)
      {//startif2

        //assemble and route MTP3_ASP
        vl_PDU_SCCP.connrefused.messageType:=cref;
        vl_PDU_SCCP.connrefused.destLocRef:=ConnectionTable[v_session].remoteReference;
        vl_PDU_SCCP.connrefused.refusalCause:=pl_N_DISCONNECT_req.reason;
        vl_PDU_SCCP.connrefused.pointer1:=0; //No optional part
        vl_PDU_SCCP.connrefused.optionalPart:=omit;
        vl_PDU_SCCP.connrefused.eop:=omit;

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send connection refused

        //release resources
        ReleaseResources(v_session);

      }//endif2
      else if (ConnectionTable[v_session].state==active)
      {//startif2

        //stop inactivity timers
        f_StopTimer(ias,v_session);
        f_StopTimer(iar,v_session);

        //assemble and route MTP3_ASP

        vl_PDU_SCCP.released.messageType:=rlsd;
        vl_PDU_SCCP.released.destLocRef:=ConnectionTable[v_session].remoteReference;
        vl_PDU_SCCP.released.sourceLocRef:=ConnectionTable[v_session].localReference;
        vl_PDU_SCCP.released.releaseCause:=pl_N_DISCONNECT_req.reason;
        if(ispresent(pl_N_DISCONNECT_req.userData)){
          vl_opt_part_present:=true;
          vl_PDU_SCCP.released.optionalPart.data.paramName:=con_SCCP_data;
          vl_PDU_SCCP.released.optionalPart.data.paramLength:=lengthof(pl_N_DISCONNECT_req.userData);
          vl_PDU_SCCP.released.optionalPart.data.data:=pl_N_DISCONNECT_req.userData;
        } else {
          vl_PDU_SCCP.released.optionalPart.data:=omit;
        }
        if(ispresent(pl_N_DISCONNECT_req.importance)){
          vl_opt_part_present:=true;
          vl_PDU_SCCP.released.optionalPart.importance.paramName:=con_SCCP_imp
          vl_PDU_SCCP.released.optionalPart.importance.paramLength:=1
          vl_PDU_SCCP.released.optionalPart.importance.importance:=pl_N_DISCONNECT_req.importance
          vl_PDU_SCCP.released.optionalPart.importance.reserved:='00000'B
        } else {
          vl_PDU_SCCP.released.optionalPart.importance:=omit;
        }
        if(vl_opt_part_present){
          vl_PDU_SCCP.released.pointer1:=1;
          vl_PDU_SCCP.released.eop.paramName:=con_SCCP_eop;
        } else {
          vl_PDU_SCCP.released.pointer1:=0;//No optional part
          vl_PDU_SCCP.released.optionalPart:=omit;
          vl_PDU_SCCP.released.eop:=omit;
        }

        MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send released

        //start release timer
        f_StartTimer(rel,v_session);

        ConnectionTable[v_session].state:=disconnect_pending;

      }//endif2
      else if (ConnectionTable[v_session].state==connection_pending_OG)
      {//startif2

        //change state to "wait connection confirm "
        ConnectionTable[v_session].state:=wait_conn_confirm;
        //and return

      }//endif2
      else { log("N_DISCONNECT_req received in an unexpected state");}

    }//endif1

  }//processing_ASP_N_DISCONNECT_req


  //******************************************************************
  //  function SCCP_SPC_int2bit - working function to processing_ASP_N_UNITDATA_req
  // v_sio is local to SCCP_CT
  // SCCPServiceType
  //******************************************************************
  function SCCP_SPC_int2bit( in integer pl_SPC, in SCCP_ServiceType pl_SCCP_ServiceType, in octetstring pl_SIO )
  return SCCP_ASPfield_SignallingPointCode
  {
    var SCCP_ASPfield_SignallingPointCode vl_SPC; //bitstring
    vl_SPC :='0000000000000000'B;

    if( (pl_SCCP_ServiceType == mtp3_itu) or (pl_SCCP_ServiceType == mtp3b_itu))
    {
       //vl_SPC := '00'B&int2bit( pl_SPC, 14);
       vl_SPC := int2bit( pl_SPC, 14);
    }
    else if ( (pl_SCCP_ServiceType == mtp3_ansi) or  (pl_SCCP_ServiceType == mtp3b_ansi) )
    {
       vl_SPC := int2bit( pl_SPC, 24);
    }
    else if( (pl_SCCP_ServiceType == mtp3_ttc) or (pl_SCCP_ServiceType == mtp3b_ttc) )
    {
      if( (pl_SIO == '83'O) or (pl_SIO == '43'O) or (pl_SIO == 'C3'O) ) //ttc national
      {
        vl_SPC := int2bit( pl_SPC, 16);
      }
      else if( pl_SIO == '03'O ) //ttc international
      {
        //vl_SPC := '00'B&int2bit( pl_SPC, 14);
        vl_SPC := int2bit( pl_SPC, 14);
      }
      else { log ( "SIO setting error"); }
    }
    else if( pl_SCCP_ServiceType == mtp3_mpt )
    {
      var integer vl_NI := oct2int(pl_SIO)/64;
      if( vl_NI == 2 ) //mpt national
      {
        vl_SPC := int2bit( pl_SPC, 24);
      }
      else //mpt international
      {
        vl_SPC := int2bit( pl_SPC, 14);
      }
    }
    else
    { log ( "ServiceType setting error. Use values",
            "mtp3_itu, mtp3b_itu, mtp3_ansi, mtp3b_ansi,",
            " mtp3_ttc, mtp3b_ttc, mtp3_mpt or m3ua");
    }

    return vl_SPC;

  }// SCCP_SPC_int2bit

  //******************************************************************
  //  sending_udt_in_ASP_MTP_TRANSFERreqs
  //  sends data in one step
  //******************************************************************
  function sending_udt_in_ASP_MTP_TRANSFERreqs( in SCCP_param_ProtocolClass     pl_protClass,
                                                in SCCP_param_CPartyAddressEnc  pl_CalledPAddress,
                                                in SCCP_param_CPartyAddressEnc  pl_CallingPAddress,
                                                in SCCP_param_Data              pl_data)
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;
    vl_PDU_SCCP.unitdata.messageType    := udt ;
    vl_PDU_SCCP.unitdata.protClass      := pl_protClass;
    vl_PDU_SCCP.unitdata.calledPAddress := pl_CalledPAddress;
    vl_PDU_SCCP.unitdata.callingPAddress:= pl_CallingPAddress;
    vl_PDU_SCCP.unitdata.data           := pl_data;
    vl_PDU_SCCP.unitdata.pointer1 := 0;
    vl_PDU_SCCP.unitdata.pointer2 := 0;
    vl_PDU_SCCP.unitdata.pointer3 := 0;

    MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
          (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP));//send Unitdata
    return;

  }//sending_udt_in_ASP_MTP_TRANSFERreqs

  //******************************************************************
  //  sending_xudt_in_ASP_MTP_TRANSFERreqs
  //  segmentates and sends data to the encoder
  //******************************************************************
  function sending_xudt_in_ASP_MTP_TRANSFERreqs(in SCCP_param_ProtocolClass     pl_protClass,
                                                in SCCP_param_CPartyAddressEnc  pl_CalledPAddress,
                                                in SCCP_param_CPartyAddressEnc  pl_CallingPAddress,
                                                in SCCP_param_Data              pl_data)
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;
    var integer vl_actdatalen; //without length of paramLength field
    var integer vl_len; // remaining data length without length of paramLength field
    var integer vl_from;
    var integer vl_overhead;
    var integer vl_maxdatalen;
    var integer vl_numberofPDUs; // ... to be sent

    vl_PDU_SCCP.extudata.messageType            := xudt ; //len:1
    vl_PDU_SCCP.extudata.hopCounter := 15; // check it in spec. //len:1
    vl_PDU_SCCP.extudata.protClass              := pl_protClass; //len:1
    vl_PDU_SCCP.extudata.pointer1               := 0; //len:4
    vl_PDU_SCCP.extudata.pointer2               := 0;
    vl_PDU_SCCP.extudata.pointer3               := 0;
    vl_PDU_SCCP.extudata.pointer4               := 0;
    vl_PDU_SCCP.extudata.calledPAddress         := pl_CalledPAddress;
    vl_PDU_SCCP.extudata.callingPAddress        := pl_CallingPAddress;

    vl_overhead := 15 +
                    (vl_PDU_SCCP.extudata.calledPAddress.paramLength+1) +
                    (vl_PDU_SCCP.extudata.callingPAddress.paramLength+1);

    vl_len := pl_data.paramLength;
    vl_maxdatalen := v_sccp_pdu_maxlen - vl_overhead -1; // -1:paramLength
    vl_numberofPDUs := vl_len/vl_maxdatalen; // 0 if 1 PDU exists

    // init segmentation:
    vl_PDU_SCCP.extudata.optionalPart.segmentation.segmLocalRef:= create_segmLocalRef();
    vl_PDU_SCCP.extudata.optionalPart.segmentation.firstSegm        := '1'B; //'yes'
    vl_PDU_SCCP.extudata.optionalPart.segmentation.paramName        := con_SCCP_segm;
    vl_PDU_SCCP.extudata.optionalPart.segmentation.paramLength      := 4;
    vl_PDU_SCCP.extudata.optionalPart.segmentation.remainingSegment := int2bit(vl_numberofPDUs,4);
    vl_PDU_SCCP.extudata.optionalPart.segmentation.reserved         := '00'B;

    if( pl_protClass.class == '0001'B )
    { vl_PDU_SCCP.extudata.optionalPart.segmentation.class          := '1'B; }
    else
    { vl_PDU_SCCP.extudata.optionalPart.segmentation.class          := '0'B; };

    vl_PDU_SCCP.extudata.optionalPart.importance:= omit; //len:0
    vl_PDU_SCCP.extudata.eop.paramName := con_SCCP_eop;  //len:0

    vl_from := 0;

    while ( vl_len > 0 )
    {
      vl_PDU_SCCP.extudata.optionalPart.segmentation.remainingSegment := int2bit(vl_numberofPDUs,4);

      if ( vl_len > vl_maxdatalen )
      { vl_actdatalen := vl_maxdatalen; }
      else
      { vl_actdatalen := vl_len; };

      vl_PDU_SCCP.extudata.data.data := substr( pl_data.data, vl_from, vl_actdatalen );
      vl_PDU_SCCP.extudata.data.paramLength := vl_actdatalen;

      MTP3_SCCP_PORT.send( t_ASP_MTP3_TRANSFERreq_sccp
        (v_SIO,v_own_SPC,v_remote_SPC,v_SLS,vl_PDU_SCCP)); //send PDU_SCCP_ExtUnitdata

      vl_PDU_SCCP.extudata.optionalPart.segmentation.firstSegm := '0'B; //'no'

      vl_numberofPDUs := vl_numberofPDUs -1 ;
      vl_from         := vl_from + vl_actdatalen;
      vl_len          := vl_len  - vl_actdatalen;
    }//while

    log("Last remaining Segment:", vl_PDU_SCCP.extudata.optionalPart.segmentation.remainingSegment );

    // not necessary, remove it:
    //reset_segmLocalRef(vl_PDU_SCCP.extudata.optionalPart.segmentation.segmLocalRef);
    return;
  }//sending_xudt_in_ASP_MTP_TRANSFERreqs

  //******************************************************************
  //  processing_ASP_N_UNITDATA_req
  //******************************************************************

  function processing_ASP_N_UNITDATA_req( in ASP_SCCP_N_UNITDATA_req pl_N_UNITDATA_req )
  runs on SCCP_CT
  {
    var PDU_SCCP vl_PDU_SCCP;
    var SCCP_param_ProtocolClass vl_protClass;
    var SCCP_param_CPartyAddressEnc vl_CalledPAddress, vl_CallingPAddress;
    var integer vl_overhead_length;
    var SCCP_param_Data vl_data;

    // Protocol class mapping :
    // old: vl_protClass.messageHandling:='0000'B;//no special options

    // 3.6/ Q.713: bit1-4
    if ( ispresent(pl_N_UNITDATA_req.sequenceControl) and
      (substr(pl_N_UNITDATA_req.sequenceControl,7,1) == '1'B) ) //least significant bit!
    { vl_protClass.class:='0001'B; }
    else
    { vl_protClass.class:='0000'B; } //changed to 0000 from 0001 ethbaat 2003-11-13

    // 3.6/ Q.713: bit 5-8:
    if ( ispresent(pl_N_UNITDATA_req.returnOption) and
      (substr(pl_N_UNITDATA_req.returnOption,7,1) == '1'B) ) //least significant bit!
    { vl_protClass.messageHandling:='1000'B}
    else
    { vl_protClass.messageHandling:='0000'B}

    //Called Address mapping:
    if (pl_N_UNITDATA_req.calledAddress.addressIndicator.pointCodeIndic=='1'B) //DPC included
    {//startif1

      if (bit2int(pl_N_UNITDATA_req.calledAddress.signPointCode) == v_remote_SPC ) // remote SPC
      {//startif2
        vl_CalledPAddress:=
          ConvertASPAddressToEncodedAddress(pl_N_UNITDATA_req.calledAddress);
      }
      else
      {
        log("The remote SPC in ASP_SCCP_N_UNITDATA_req is not the same as the one you called by StartSCCP.ASP dropped")
        return;
      }

    }//endif1
    else
    {  //DPC not present, use values local for component

      var SCCP_PAR_Address vl_SCCP_PAR_Address;
      vl_SCCP_PAR_Address := pl_N_UNITDATA_req.calledAddress;

      if ( v_remote_SPC > 0)
      {
        vl_SCCP_PAR_Address.addressIndicator.pointCodeIndic :='1'B; // 3.4.1/Q713.
        vl_SCCP_PAR_Address.addressIndicator.routingIndicator := cg_route_on_SSN;
        // 14,24 or 16 bits:
        vl_SCCP_PAR_Address.signPointCode    := SCCP_SPC_int2bit( v_remote_SPC, v_SCCPServiceType, v_SIO);
      }
      // vl_SCCP_PAR_Address.addressIndicator.ssnIndicator unchanged
      // vl_SCCP_PAR_Address.addressIndicator.globalTitleIndic unchanged
      // vl_SCCP_PAR_Address.subsystemNumber  unchanged
      // vl_SCCP_PAR_Address.globalTitle      unchanged

      vl_CalledPAddress :=
          ConvertASPAddressToEncodedAddress(vl_SCCP_PAR_Address);

    }//endif1

    vl_CallingPAddress :=
      ConvertASPAddressToEncodedAddress(pl_N_UNITDATA_req.callingAddress);

    vl_data.data := pl_N_UNITDATA_req.userData;
    vl_data.paramLength:= lengthof( pl_N_UNITDATA_req.userData);

    // unitdata overhead calculation:
    // msg type: 1; prot class: 2; 3 pointers: 3=> total:6
    vl_overhead_length := (vl_CalledPAddress.paramLength+1) +
                            (vl_CallingPAddress.paramLength +1)+ 6 ;

    if( (tsp_force_xudt==0) and
        (vl_overhead_length + vl_data.paramLength + 1) <=  v_sccp_pdu_maxlen )
    {
      sending_udt_in_ASP_MTP_TRANSFERreqs(vl_protClass,
                                          vl_CalledPAddress,
                                          vl_CallingPAddress,
                                          vl_data );
    }
    else
    {
      sending_xudt_in_ASP_MTP_TRANSFERreqs(vl_protClass,
                                          vl_CalledPAddress,
                                          vl_CallingPAddress,
                                          vl_data );
    }

  }//processing_ASP_N_UNITDATA_req

//******************************************************************
//******************************************************************
function ScanEvents()  runs on SCCP_CT
//******************************************************************
//******************************************************************
{//startfunction

  var       PDU_SCCP vl_PDU_SCCP;

  var        ASP_SCCP_N_CONNECT_req     vl_N_CONNECT_req;
  var        ASP_SCCP_N_CONNECT_ind     vl_N_CONNECT_ind;
  var        ASP_SCCP_N_CONNECT_res     vl_N_CONNECT_res;
  var        ASP_SCCP_N_CONNECT_cfm     vl_N_CONNECT_cfm;
  var        ASP_SCCP_N_DATA_req        vl_N_DATA_req;
  var        ASP_SCCP_N_DATA_ind        vl_N_DATA_ind;
  var        ASP_SCCP_N_DISCONNECT_req  vl_N_DISCONNECT_req;
  var        ASP_SCCP_N_DISCONNECT_ind  vl_N_DISCONNECT_ind;
  var        ASP_SCCP_N_UNITDATA_req    vl_N_UNITDATA_req;
  var        ASP_SCCP_N_UNITDATA_ind    vl_N_UNITDATA_ind;
  var        ASP_SCCP_N_NOTICE_ind      vl_N_NOTICE_ind;
  
  var integer i;
  //this function  scans the MTP3 and user port for incoming messages and checks timers for timeout
  
  f_initialize_timer_states();

  while (true)
  {//startwhile

    alt
    //******************************************************************
    {//startalt0
    //******************************************************************
    [] MTP3_SCCP_PORT.receive(PDU_SCCP : ? ) -> value vl_PDU_SCCP
      {
        //******************************************************************
        //Unitdata received at destination node
        //******************************************************************
        if (ischosen(vl_PDU_SCCP.unitdata))
        { 
    //      vl_PDU_SCCP.unitdata.pointer1 :=3;
    //      vl_PDU_SCCP.unitdata.pointer2 :=0;
    //      vl_PDU_SCCP.unitdata.pointer3 :=0;
          processing_PDU_SCCP_Unitdata( vl_PDU_SCCP.unitdata ); 
        } 

        //******************************************************************
        //Data received at destination node
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.dataform1))
        { 
    //      vl_PDU_SCCP.dataform1.pointer1 :=1;
          processing_PDU_SCCP_DataForm1( vl_PDU_SCCP.dataform1 ); 
        } 

        //******************************************************************
        //Extended unitdata received at destination node
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.extudata))
        { 
    //      vl_PDU_SCCP.extudata.pointer1 :=0;
    //      vl_PDU_SCCP.extudata.pointer2 :=0;
    //      vl_PDU_SCCP.extudata.pointer3 :=0;
    //      vl_PDU_SCCP.extudata.pointer4 :=0;
          processing_PDU_SCCP_ExtUnitdata( vl_PDU_SCCP.extudata ); 
        } 

        //******************************************************************
        //Connection request received
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.connrequest))
        { 
    //      vl_PDU_SCCP.connrequest.pointer1 :=2;
    //      vl_PDU_SCCP.connrequest.pointer2 :=0;
          processing_PDU_SCCP_ConnectionRequest( vl_PDU_SCCP.connrequest ); 
        } 

        //******************************************************************
        //Connection confirm received
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.connconfirm))
        { 
    //      vl_PDU_SCCP.connconfirm.pointer1 :=1;
          processing_PDU_SCCP_ConnectionConfirm( vl_PDU_SCCP.connconfirm ); 
        } 

        //******************************************************************
        //Released received
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.released))
        { 
    //      vl_PDU_SCCP.released.pointer1 :=1;
          processing_PDU_SCCP_Released( vl_PDU_SCCP.released ); 
        } 

        //******************************************************************
        //Release complete received
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.relcomp))
        { 
          processing_PDU_SCCP_ReleaseComplete( vl_PDU_SCCP.relcomp ); 
        } 

        //******************************************************************
        //Unitdata service  received
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.udataserv))
        { 
    //      vl_PDU_SCCP.udataserv.pointer1 :=3;
    //      vl_PDU_SCCP.udataserv.pointer2 :=0;
    //      vl_PDU_SCCP.udataserv.pointer3 :=0;
          processing_PDU_SCCP_UnitdataService( vl_PDU_SCCP.udataserv ); 
        } 

        //******************************************************************
        //PDU_Error  received
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.pduerror))
        { 
          processing_PDU_SCCP_ProtDataUnitError( vl_PDU_SCCP.pduerror ); 
        } 

        //******************************************************************
        //Inactivity test received
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.inacttest))
        { 
          processing_PDU_SCCP_InactivityTest( vl_PDU_SCCP.inacttest ); 
        } 

        //******************************************************************
        //Reset request  received
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.resetreq))
        { 
          processing_PDU_SCCP_ResetRequest( vl_PDU_SCCP.resetreq ); 
        } 

        //******************************************************************
        //Reset confirm  received
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.resconf))
        { 
          processing_PDU_SCCP_ResetConfirm( vl_PDU_SCCP.resconf ); 
        } 

        //******************************************************************
        //Connection refused received
        //******************************************************************
        else if (ischosen(vl_PDU_SCCP.connrefused))
        { 
    //      vl_PDU_SCCP.connrefused.pointer1 :=1;
          processing_PDU_SCCP_ConnectionRefused( vl_PDU_SCCP.connrefused ); 
        }
        else
        { log ("Unsupported message received and discarded"); }
      }

    []MTP3_SCCP_PORT.receive 
      { log("Unsupported or unrecognized message discarded after reception") }

    //******************************************************************
    //******************************************************************
    ////start second alternative-message received on user  port
    //******************************************************************
    //******************************************************************

    [] SCCP_SP_PORT.check  
    {//start second alternative

      alt { //startalt1-subalternatives vill follow

          //******************************************************************
          //N_DATA_req
          //******************************************************************
          [] SCCP_SP_PORT.receive( tr_ASP_N_DATA_req)-> value vl_N_DATA_req
            { processing_ASP_N_DATA_req(vl_N_DATA_req); }

          //******************************************************************
          //N_UNITDATA_req at originating node
          //******************************************************************
          [] SCCP_SP_PORT.receive( tr_ASP_N_UNITDATA_req ) -> value vl_N_UNITDATA_req
            { processing_ASP_N_UNITDATA_req(vl_N_UNITDATA_req); }

           //******************************************************************
          //N_CONNECT_req ,   originating  node
          //******************************************************************
          [] SCCP_SP_PORT.receive( tr_ASP_N_CONNECT_req) -> value vl_N_CONNECT_req
            { processing_ASP_N_CONNECT_req( vl_N_CONNECT_req);}

          //******************************************************************
          //N_CONNECT_resp
          //******************************************************************
          [] SCCP_SP_PORT.receive( tr_ASP_N_CONNECT_res)-> value vl_N_CONNECT_res
          { processing_ASP_N_CONNECT_res(vl_N_CONNECT_res); }

         //******************************************************************
          //N_DISCONNECT_req
          //******************************************************************
          [] SCCP_SP_PORT.receive( tr_ASP_N_DISCONNECT_req)-> value vl_N_DISCONNECT_req
            { processing_ASP_N_DISCONNECT_req(vl_N_DISCONNECT_req); }

          //******************************************************************
          //N_RESET_resp  //will not be received!!
          //******************************************************************
          //[] SCCP_SP_PORT.receive( tr_ASP_N_RESET_resp)-> value vl_N_RESET_resp;

          //******************************************************************
          //N_RESET_req  //will not be received!!
          //******************************************************************
          //[] SCCP_SP_PORT.receive( tr_ASP_N_RESET_req)-> value vl_N_RESET_req;

          //******************************************************************
          //If none of the above , then message is removed from the top of the
          //stack and discarded
          //******************************************************************
          [] SCCP_SP_PORT.receive
            { }

          }//endalt1

    }//end second alternative-message received on user port

        //******************************************************************
        //connection timer expired
        //******************************************************************   
        [v_T_conn_est[0]]        T_conn_est[0].timeout         {Conn_Timer_Expired(0);
                                                                v_T_conn_est[0] := false;}
        [v_T_conn_est[1]]        T_conn_est[1].timeout         {Conn_Timer_Expired(1);
                                                                v_T_conn_est[1] := false;}
        [v_T_conn_est[2]]        T_conn_est[2].timeout         {Conn_Timer_Expired(2);
                                                                v_T_conn_est[2] := false;}
        [v_T_conn_est[3]]        T_conn_est[3].timeout         {Conn_Timer_Expired(3);
                                                                v_T_conn_est[3] := false;}
        [v_T_conn_est[4]]        T_conn_est[4].timeout         {Conn_Timer_Expired(4);
                                                                v_T_conn_est[4] := false;}
        [v_T_conn_est[5]]        T_conn_est[5].timeout         {Conn_Timer_Expired(5);
                                                                v_T_conn_est[5] := false;}
        [v_T_conn_est[6]]        T_conn_est[6].timeout         {Conn_Timer_Expired(6);
                                                                v_T_conn_est[6] := false;}
        [v_T_conn_est[7]]        T_conn_est[7].timeout         {Conn_Timer_Expired(7);
                                                                v_T_conn_est[7] := false;}
        [v_T_conn_est[8]]        T_conn_est[8].timeout         {Conn_Timer_Expired(8);
                                                                v_T_conn_est[8] := false;}
        [v_T_conn_est[9]]        T_conn_est[9].timeout         {Conn_Timer_Expired(9);
                                                                v_T_conn_est[9] := false;}
        [v_T_conn_est[10]]        T_conn_est[10].timeout         {Conn_Timer_Expired(10);
                                                                v_T_conn_est[10] := false;}
        [v_T_conn_est[11]]        T_conn_est[11].timeout         {Conn_Timer_Expired(11);
                                                                v_T_conn_est[11] := false;}
        [v_T_conn_est[12]]        T_conn_est[12].timeout         {Conn_Timer_Expired(12);
                                                                v_T_conn_est[12] := false;}
        [v_T_conn_est[13]]        T_conn_est[13].timeout         {Conn_Timer_Expired(13);
                                                                v_T_conn_est[13] := false;}
        [v_T_conn_est[14]]        T_conn_est[14].timeout         {Conn_Timer_Expired(14);
                                                                v_T_conn_est[14] := false;}
        [v_T_conn_est[15]]        T_conn_est[15].timeout         {Conn_Timer_Expired(15);
                                                                v_T_conn_est[15] := false;}
        
        //******************************************************************
        //send inactivity timer expired
        //******************************************************************        
        
        [v_T_ias[0]]             T_ias[0].timeout              {SendInactivity_Timer_Expired(0);
                                                                v_T_ias[0] := false;}
        [v_T_ias[1]]             T_ias[1].timeout              {SendInactivity_Timer_Expired(1);
                                                                v_T_ias[1] := false;}
        [v_T_ias[2]]             T_ias[2].timeout              {SendInactivity_Timer_Expired(2);
                                                                v_T_ias[2] := false;}
        [v_T_ias[3]]             T_ias[3].timeout              {SendInactivity_Timer_Expired(3);
                                                                v_T_ias[3] := false;}
        [v_T_ias[4]]             T_ias[4].timeout              {SendInactivity_Timer_Expired(4);
                                                                v_T_ias[4] := false;}
        [v_T_ias[5]]             T_ias[5].timeout              {SendInactivity_Timer_Expired(5);
                                                                v_T_ias[5] := false;}
        [v_T_ias[6]]             T_ias[6].timeout              {SendInactivity_Timer_Expired(6);
                                                                v_T_ias[6] := false;}
        [v_T_ias[7]]             T_ias[7].timeout              {SendInactivity_Timer_Expired(7);
                                                                v_T_ias[7] := false;}
        [v_T_ias[8]]             T_ias[8].timeout              {SendInactivity_Timer_Expired(8);
                                                                v_T_ias[8] := false;}
        [v_T_ias[9]]             T_ias[9].timeout              {SendInactivity_Timer_Expired(9);
                                                                v_T_ias[i] := false;}
        [v_T_ias[10]]             T_ias[10].timeout              {SendInactivity_Timer_Expired(10);
                                                                v_T_ias[10] := false;}
        [v_T_ias[11]]             T_ias[11].timeout              {SendInactivity_Timer_Expired(11);
                                                                v_T_ias[11] := false;}
        [v_T_ias[12]]             T_ias[12].timeout              {SendInactivity_Timer_Expired(12);
                                                                v_T_ias[12] := false;}
        [v_T_ias[13]]             T_ias[13].timeout              {SendInactivity_Timer_Expired(13);
                                                                v_T_ias[13] := false;}
        [v_T_ias[14]]             T_ias[14].timeout              {SendInactivity_Timer_Expired(14);
                                                                v_T_ias[14] := false;}
        [v_T_ias[15]]             T_ias[15].timeout              {SendInactivity_Timer_Expired(15);
                                                                v_T_ias[15] := false;}
        
        //******************************************************************
        //receive inactivity timer expired
        //******************************************************************        
        [v_T_iar[0]]             T_iar[0].timeout              {ReceiveInactivity_Timer_Expired(0);
                                                                v_T_iar[0] := false;}
        [v_T_iar[1]]             T_iar[1].timeout              {ReceiveInactivity_Timer_Expired(1);
                                                                v_T_iar[1] := false;}
        [v_T_iar[2]]             T_iar[2].timeout              {ReceiveInactivity_Timer_Expired(2);
                                                                v_T_iar[2] := false;}
        [v_T_iar[3]]             T_iar[3].timeout              {ReceiveInactivity_Timer_Expired(3);
                                                                v_T_iar[3] := false;}
        [v_T_iar[4]]             T_iar[4].timeout              {ReceiveInactivity_Timer_Expired(4);
                                                                v_T_iar[4] := false;}
        [v_T_iar[5]]             T_iar[5].timeout              {ReceiveInactivity_Timer_Expired(5);
                                                                v_T_iar[5] := false;}
        [v_T_iar[6]]             T_iar[6].timeout              {ReceiveInactivity_Timer_Expired(6);
                                                                v_T_iar[6] := false;}
        [v_T_iar[7]]             T_iar[7].timeout              {ReceiveInactivity_Timer_Expired(7);
                                                                v_T_iar[7] := false;}
        [v_T_iar[8]]             T_iar[8].timeout              {ReceiveInactivity_Timer_Expired(8);
                                                                v_T_iar[8] := false;}
        [v_T_iar[9]]             T_iar[9].timeout              {ReceiveInactivity_Timer_Expired(9);
                                                                v_T_iar[9] := false;}
        [v_T_iar[10]]             T_iar[10].timeout              {ReceiveInactivity_Timer_Expired(10);
                                                                v_T_iar[10] := false;}
        [v_T_iar[11]]             T_iar[11].timeout              {ReceiveInactivity_Timer_Expired(11);
                                                                v_T_iar[11] := false;}
        [v_T_iar[12]]             T_iar[12].timeout              {ReceiveInactivity_Timer_Expired(12);
                                                                v_T_iar[12] := false;}
        [v_T_iar[13]]             T_iar[13].timeout              {ReceiveInactivity_Timer_Expired(13);
                                                                v_T_iar[13] := false;}
        [v_T_iar[14]]             T_iar[14].timeout              {ReceiveInactivity_Timer_Expired(14);
                                                                v_T_iar[14] := false;}
        [v_T_iar[15]]             T_iar[15].timeout              {ReceiveInactivity_Timer_Expired(15);
                                                                v_T_iar[15] := false;}
         
        //******************************************************************
        //release timer expired
        //******************************************************************        
        [v_T_rel[0]]             T_rel[0].timeout              {Release_Timer_Expired(0);
                                                                v_T_rel[0] := false;}
        [v_T_rel[1]]             T_rel[1].timeout              {Release_Timer_Expired(1);
                                                                v_T_rel[1] := false;}
        [v_T_rel[2]]             T_rel[2].timeout              {Release_Timer_Expired(2);
                                                                v_T_rel[2] := false;}
        [v_T_rel[3]]             T_rel[3].timeout              {Release_Timer_Expired(3);
                                                                v_T_rel[3] := false;}
        [v_T_rel[4]]             T_rel[4].timeout              {Release_Timer_Expired(4);
                                                                v_T_rel[4] := false;}
        [v_T_rel[5]]             T_rel[5].timeout              {Release_Timer_Expired(5);
                                                                v_T_rel[5] := false;}
        [v_T_rel[6]]             T_rel[6].timeout              {Release_Timer_Expired(6);
                                                                v_T_rel[6] := false;}
        [v_T_rel[7]]             T_rel[7].timeout              {Release_Timer_Expired(7);
                                                                v_T_rel[7] := false;}
        [v_T_rel[8]]             T_rel[8].timeout              {Release_Timer_Expired(8);
                                                                v_T_rel[8] := false;}
        [v_T_rel[9]]             T_rel[9].timeout              {Release_Timer_Expired(9);
                                                                v_T_rel[9] := false;}
        [v_T_rel[10]]             T_rel[10].timeout              {Release_Timer_Expired(10);
                                                                v_T_rel[10] := false;}
        [v_T_rel[11]]             T_rel[11].timeout              {Release_Timer_Expired(11);
                                                                v_T_rel[11] := false;}
        [v_T_rel[12]]             T_rel[12].timeout              {Release_Timer_Expired(12);
                                                                v_T_rel[12] := false;}
        [v_T_rel[13]]             T_rel[13].timeout              {Release_Timer_Expired(13);
                                                                v_T_rel[13] := false;}
        [v_T_rel[14]]             T_rel[14].timeout              {Release_Timer_Expired(14);
                                                                v_T_rel[14] := false;}
        [v_T_rel[15]]             T_rel[15].timeout              {Release_Timer_Expired(15);
                                                                v_T_rel[15] := false;}
                
        //******************************************************************
        //repeat release timer expired
        //******************************************************************        
        
        [v_T_repeat_rel[0]]             T_repeat_rel[0].timeout              {RepeatRelease_Timer_Expired(0);
                                                                v_T_repeat_rel[0] := false;}
        [v_T_repeat_rel[1]]             T_repeat_rel[1].timeout              {RepeatRelease_Timer_Expired(1);
                                                                v_T_repeat_rel[1] := false;}
        [v_T_repeat_rel[2]]             T_repeat_rel[2].timeout              {RepeatRelease_Timer_Expired(2);
                                                                v_T_repeat_rel[2] := false;}
        [v_T_repeat_rel[3]]             T_repeat_rel[3].timeout              {RepeatRelease_Timer_Expired(3);
                                                                v_T_repeat_rel[3] := false;}
        [v_T_repeat_rel[4]]             T_repeat_rel[4].timeout              {RepeatRelease_Timer_Expired(4);
                                                                v_T_repeat_rel[4] := false;}
        [v_T_repeat_rel[5]]             T_repeat_rel[5].timeout              {RepeatRelease_Timer_Expired(5);
                                                                v_T_repeat_rel[5] := false;}
        [v_T_repeat_rel[6]]             T_repeat_rel[6].timeout              {RepeatRelease_Timer_Expired(6);
                                                                v_T_repeat_rel[6] := false;}
        [v_T_repeat_rel[7]]             T_repeat_rel[7].timeout              {RepeatRelease_Timer_Expired(7);
                                                                v_T_repeat_rel[7] := false;}
        [v_T_repeat_rel[8]]             T_repeat_rel[8].timeout              {RepeatRelease_Timer_Expired(8);
                                                                v_T_repeat_rel[8] := false;}
        [v_T_repeat_rel[9]]             T_repeat_rel[9].timeout              {RepeatRelease_Timer_Expired(9);
                                                                v_T_repeat_rel[9] := false;}
        [v_T_repeat_rel[10]]             T_repeat_rel[10].timeout              {RepeatRelease_Timer_Expired(10);
                                                                v_T_repeat_rel[10] := false;}
        [v_T_repeat_rel[11]]             T_repeat_rel[11].timeout              {RepeatRelease_Timer_Expired(11);
                                                                v_T_repeat_rel[11] := false;}
        [v_T_repeat_rel[12]]             T_repeat_rel[12].timeout              {RepeatRelease_Timer_Expired(12);
                                                                v_T_repeat_rel[12] := false;}
        [v_T_repeat_rel[13]]             T_repeat_rel[13].timeout              {RepeatRelease_Timer_Expired(13);
                                                                v_T_repeat_rel[13] := false;}
        [v_T_repeat_rel[14]]             T_repeat_rel[14].timeout              {RepeatRelease_Timer_Expired(14);
                                                                v_T_repeat_rel[14] := false;}
        [v_T_repeat_rel[15]]             T_repeat_rel[15].timeout              {RepeatRelease_Timer_Expired(15);
                                                                v_T_repeat_rel[15] := false;}
        
        //******************************************************************
        //interval timer expired
        //******************************************************************        
        [v_T_int[0]]             T_int[0].timeout              {Interval_Timer_Expired(0);
                                                                v_T_int[0] := false;}
        [v_T_int[1]]             T_int[1].timeout              {Interval_Timer_Expired(1);
                                                                v_T_int[1] := false;}
        [v_T_int[2]]             T_int[2].timeout              {Interval_Timer_Expired(2);
                                                                v_T_int[2] := false;}
        [v_T_int[3]]             T_int[3].timeout              {Interval_Timer_Expired(3);
                                                                v_T_int[3] := false;}
        [v_T_int[4]]             T_int[4].timeout              {Interval_Timer_Expired(4);
                                                                v_T_int[4] := false;}
        [v_T_int[5]]             T_int[5].timeout              {Interval_Timer_Expired(5);
                                                                v_T_int[5] := false;}
        [v_T_int[6]]             T_int[6].timeout              {Interval_Timer_Expired(6);
                                                                v_T_int[6] := false;}
        [v_T_int[7]]             T_int[7].timeout              {Interval_Timer_Expired(7);
                                                                v_T_int[7] := false;}
        [v_T_int[8]]             T_int[8].timeout              {Interval_Timer_Expired(8);
                                                                v_T_int[8] := false;}
        [v_T_int[9]]             T_int[9].timeout              {Interval_Timer_Expired(9);
                                                                v_T_int[9] := false;}
        [v_T_int[10]]             T_int[10].timeout              {Interval_Timer_Expired(10);
                                                                v_T_int[10] := false;}
        [v_T_int[11]]             T_int[11].timeout              {Interval_Timer_Expired(11);
                                                                v_T_int[11] := false;}
        [v_T_int[12]]             T_int[12].timeout              {Interval_Timer_Expired(12);
                                                                v_T_int[12] := false;}
        [v_T_int[13]]             T_int[13].timeout              {Interval_Timer_Expired(13);
                                                                v_T_int[13] := false;}
        [v_T_int[14]]             T_int[14].timeout              {Interval_Timer_Expired(14);
                                                                v_T_int[14] := false;}
        [v_T_int[15]]             T_int[15].timeout              {Interval_Timer_Expired(15);
                                                                v_T_int[15] := false;}
        
        //******************************************************************
        //reset timer expired
        //******************************************************************                       
        [v_T_reset[0]]             T_reset[0].timeout              {Reset_Timer_Expired(0);
                                                                v_T_reset[0] := false;}
        [v_T_reset[1]]             T_reset[1].timeout              {Reset_Timer_Expired(1);
                                                                v_T_reset[1] := false;}
        [v_T_reset[2]]             T_reset[2].timeout              {Reset_Timer_Expired(2);
                                                                v_T_reset[2] := false;}
        [v_T_reset[3]]             T_reset[3].timeout              {Reset_Timer_Expired(3);
                                                                v_T_reset[3] := false;}
        [v_T_reset[4]]             T_reset[4].timeout              {Reset_Timer_Expired(4);
                                                                v_T_reset[4] := false;}
        [v_T_reset[5]]             T_reset[5].timeout              {Reset_Timer_Expired(5);
                                                                v_T_reset[5] := false;}
        [v_T_reset[6]]             T_reset[6].timeout              {Reset_Timer_Expired(6);
                                                                v_T_reset[6] := false;}
        [v_T_reset[7]]             T_reset[7].timeout              {Reset_Timer_Expired(7);
                                                                v_T_reset[7] := false;}
        [v_T_reset[8]]             T_reset[8].timeout              {Reset_Timer_Expired(8);
                                                                v_T_reset[8] := false;}
        [v_T_reset[9]]             T_reset[9].timeout              {Reset_Timer_Expired(9);
                                                                v_T_reset[9] := false;}
        [v_T_reset[10]]             T_reset[10].timeout              {Reset_Timer_Expired(10);
                                                                v_T_reset[10] := false;}
        [v_T_reset[11]]             T_reset[11].timeout              {Reset_Timer_Expired(11);
                                                                v_T_reset[11] := false;}
        [v_T_reset[12]]             T_reset[12].timeout              {Reset_Timer_Expired(12);
                                                                v_T_reset[12] := false;}
        [v_T_reset[13]]             T_reset[13].timeout              {Reset_Timer_Expired(13);
                                                                v_T_reset[13] := false;}
        [v_T_reset[14]]             T_reset[14].timeout              {Reset_Timer_Expired(14);
                                                                v_T_reset[14] := false;}
        [v_T_reset[15]]             T_reset[15].timeout              {Reset_Timer_Expired(15);
                                                                v_T_reset[15] := false;}
        
        //******************************************************************
        //internal_reset timer expired-sending internal signals!
        //******************************************************************                        
       [v_T_internal_reset[0]]             T_internal_reset[0].timeout              {InternalResetTimer_Expired(0);
                                                                v_T_internal_reset[0] := false;}
        [v_T_internal_reset[1]]             T_internal_reset[1].timeout              {InternalResetTimer_Expired(1);
                                                                v_T_internal_reset[1] := false;}
        [v_T_internal_reset[2]]             T_internal_reset[2].timeout              {InternalResetTimer_Expired(2);
                                                                v_T_internal_reset[2] := false;}
        [v_T_internal_reset[3]]             T_internal_reset[3].timeout              {InternalResetTimer_Expired(3);
                                                                v_T_internal_reset[3] := false;}
        [v_T_internal_reset[4]]             T_internal_reset[4].timeout              {InternalResetTimer_Expired(4);
                                                                v_T_internal_reset[4] := false;}
        [v_T_internal_reset[5]]             T_internal_reset[5].timeout              {InternalResetTimer_Expired(5);
                                                                v_T_internal_reset[5] := false;}
        [v_T_internal_reset[6]]             T_internal_reset[6].timeout              {InternalResetTimer_Expired(6);
                                                                v_T_internal_reset[6] := false;}
        [v_T_internal_reset[7]]             T_internal_reset[7].timeout              {InternalResetTimer_Expired(7);
                                                                v_T_internal_reset[7] := false;}
        [v_T_internal_reset[8]]             T_internal_reset[8].timeout              {InternalResetTimer_Expired(8);
                                                                v_T_internal_reset[8] := false;}
        [v_T_internal_reset[9]]             T_internal_reset[9].timeout              {InternalResetTimer_Expired(9);
                                                                v_T_internal_reset[9] := false;}
        [v_T_internal_reset[10]]             T_internal_reset[10].timeout              {InternalResetTimer_Expired(10);
                                                                v_T_internal_reset[10] := false;}
        [v_T_internal_reset[11]]             T_internal_reset[11].timeout              {InternalResetTimer_Expired(11);
                                                                v_T_internal_reset[11] := false;}
        [v_T_internal_reset[12]]             T_internal_reset[12].timeout              {InternalResetTimer_Expired(12);
                                                                v_T_internal_reset[12] := false;}
        [v_T_internal_reset[13]]             T_internal_reset[13].timeout              {InternalResetTimer_Expired(13);
                                                                v_T_internal_reset[13] := false;}
        [v_T_internal_reset[14]]             T_internal_reset[14].timeout              {InternalResetTimer_Expired(14);
                                                                v_T_internal_reset[14] := false;}
        [v_T_internal_reset[15]]             T_internal_reset[15].timeout              {InternalResetTimer_Expired(15);
                                                                v_T_internal_reset[15] := false;}
        
       //******************************************************************
       //guard timer expired - no answer to ASP_SCCP_N_CONNECT_ind received
       //******************************************************************                        
        [v_T_guard[0]]             T_guard[0].timeout              {GuardTimer_Expired(0);
                                                                v_T_guard[0] := false;}
        [v_T_guard[1]]             T_guard[1].timeout              {GuardTimer_Expired(1);
                                                                v_T_guard[1] := false;}
        [v_T_guard[2]]             T_guard[2].timeout              {GuardTimer_Expired(2);
                                                                v_T_guard[2] := false;}
        [v_T_guard[3]]             T_guard[3].timeout              {GuardTimer_Expired(3);
                                                                v_T_guard[3] := false;}
        [v_T_guard[4]]             T_guard[4].timeout              {GuardTimer_Expired(4);
                                                                v_T_guard[4] := false;}
        [v_T_guard[5]]             T_guard[5].timeout              {GuardTimer_Expired(5);
                                                                v_T_guard[5] := false;}
        [v_T_guard[6]]             T_guard[6].timeout              {GuardTimer_Expired(6);
                                                                v_T_guard[6] := false;}
        [v_T_guard[7]]             T_guard[7].timeout              {GuardTimer_Expired(7);
                                                                v_T_guard[7] := false;}
        [v_T_guard[8]]             T_guard[8].timeout              {GuardTimer_Expired(8);
                                                                v_T_guard[8] := false;}
        [v_T_guard[9]]             T_guard[9].timeout              {GuardTimer_Expired(9);
                                                                v_T_guard[9] := false;}
        [v_T_guard[10]]             T_guard[10].timeout              {GuardTimer_Expired(10);
                                                                v_T_guard[10] := false;}
        [v_T_guard[11]]             T_guard[11].timeout              {GuardTimer_Expired(11);
                                                                v_T_guard[11] := false;}
        [v_T_guard[12]]             T_guard[12].timeout              {GuardTimer_Expired(12);
                                                                v_T_guard[12] := false;}
        [v_T_guard[13]]             T_guard[13].timeout              {GuardTimer_Expired(13);
                                                                v_T_guard[13] := false;}
        [v_T_guard[14]]             T_guard[14].timeout              {GuardTimer_Expired(14);
                                                                v_T_guard[14] := false;}
        [v_T_guard[15]]             T_guard[15].timeout              {GuardTimer_Expired(15);
                                                                v_T_guard[15] := false;}


    }//endalt0

  //******************************************************************
  }//endwhile
  //******************************************************************

}//endfunction ScanEvents

//******************************************************************
}//endgroup SCCPFunctions
//******************************************************************

}//endmodule
