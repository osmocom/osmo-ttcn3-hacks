module GprsModem_Tests {

/* Integration Tests for MS side GPRS implementation.
 *
 * (C) 2022 by sysmocom - s.f.m.c. GmbH <info@sysmocom.de>
 * Author: Vadim Yanitskiy <vyanitskiy@sysmocom.de>
 * All rights reserved.
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 *
 * Released under the terms of GNU General Public License, Version 2 or
 * (at your option) any later version.
 */

import from Misc_Helpers all;
import from General_Types all;
import from GSM_Types all;
import from GSM_RR_Types all;
import from Osmocom_Types all;
import from L1CTL_PortType all;
import from L1CTL_Types all;
import from Native_Functions all;

import from RLCMAC_Types all;
import from RLCMAC_Templates all;

type component test_CT {
	port L1CTL_PT L1CTL;
};

private type enumerated PdchBlockType {
	PDCH_BT_PDTCH,
	PDCH_BT_PTCCH
};

private function f_init() runs on test_CT
{
	map(self:L1CTL, system:L1CTL);
	f_connect_reset(L1CTL);
}

private function f_pdch_activate(L1CTL_PT pt, uint3_t tn)
{
	/* l1gprs_test treats L1CTL_DM_EST_REQ as PDCH activation */
	pt.send(ts_L1CTL_DM_EST_REQ_H0(chan_nr := ts_RslChanNr_PDCH(tn),
				       tsc := 0, arfcn := 0));
}

private function f_pdch_deactivate(L1CTL_PT pt, uint3_t tn)
{
	/* l1gprs_test treats L1CTL_DM_REL_REQ as PDCH deactivation */
	pt.send(ts_L1CTL_DM_REL_REQ(chan_nr := ts_RslChanNr_PDCH(tn)));
}

private function f_pdch_tx_block(L1CTL_PT pt, uint3_t tn, uint32_t fn,
				 octetstring block_data,
				 PdchBlockType bt := PDCH_BT_PDTCH)
{
	template (value) GsmBandArfcn arfcn := ts_GsmBandArfcn(0);
	var RslLinkId link_id := valueof(ts_RslLinkID_DCCH(0));

	/* l1gprs_test uses link_id to distinguish PDTCH and PTCCH */
	select (bt) {
	case (PDCH_BT_PDTCH) { link_id.c := FACCH_SDCCH };
	case (PDCH_BT_PTCCH) { link_id.c := OSMO_PTCCH };
	}

	/* l1gprs_test treats L1CTL_DATA_IND as a Downlink PDCH block */
	pt.send(ts_L1CTL_DATA_IND(chan_nr := ts_RslChanNr_PDCH(tn),
				  link_id := link_id,
				  l2_data := block_data,
				  arfcn := arfcn));
}

private function f_pdch_tx_ptcch(L1CTL_PT pt, uint3_t tn, uint32_t fn,
				 template (value) PTCCHDownlinkMsg msg)
{
	var octetstring block_data := enc_PTCCHDownlinkMsg(valueof(msg));
	f_pdch_tx_block(pt, tn, fn, block_data, bt := PDCH_BT_PTCCH);
}

private function f_pdch_tx_ctrl(L1CTL_PT pt, uint3_t tn, uint32_t fn,
				template (value) RlcmacDlBlock block)
{
	var octetstring block_data;

	if (not ischosen(block.ctrl)) {
		setverdict(inconc, "f_pdch_tx_ctrl(): a CTRL block was expected");
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__);
	}

	block_data := enc_RlcmacDlBlock(valueof(block));
	block_data := f_pad_oct(block_data, 23, '2B'O);
	f_pdch_tx_block(pt, tn, fn, block_data, bt := PDCH_BT_PDTCH);
}

private function f_pdch_tx_data(L1CTL_PT pt, uint3_t tn, uint32_t fn,
				template (value) RlcmacDlBlock block)
{
	var octetstring block_data;

	if (not ischosen(block.ctrl) and not ischosen(block.data_egprs)) {
		setverdict(inconc, "f_pdch_tx_ctrl(): a DATA block was expected");
		Misc_Helpers.f_shutdown(__BFILE__, __LINE__);
	}

	block_data := enc_RlcmacDlBlock(valueof(block));
	/* XXX: do we need to add padding (based on CS) here? */
	f_pdch_tx_block(pt, tn, fn, block_data, bt := PDCH_BT_PDTCH);
}

testcase TC_tuwat() runs on test_CT
{
	f_init();

	f_pdch_activate(L1CTL, 7);
	f_pdch_tx_ctrl(L1CTL, 7, 1337, ts_RLCMAC_DL_DUMMY_CTRL);
	f_pdch_tx_ctrl(L1CTL, 7, 1337, ts_RLCMAC_DL_DUMMY_CTRL);
	f_pdch_tx_ctrl(L1CTL, 7, 1337, ts_RLCMAC_DL_DUMMY_CTRL);
	f_pdch_tx_ptcch(L1CTL, 7, 1337, ts_PTCCHDownlinkMsg);
	setverdict(pass);
}

}
